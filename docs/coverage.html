
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tranm/gassigeher/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/tranm/gassigeher/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/tranm/gassigeher/internal/cron/cron.go (32.8%)</option>
				
				<option value="file3">github.com/tranm/gassigeher/internal/database/database.go (0.0%)</option>
				
				<option value="file4">github.com/tranm/gassigeher/internal/handlers/auth_handler.go (51.4%)</option>
				
				<option value="file5">github.com/tranm/gassigeher/internal/handlers/blocked_date_handler.go (74.2%)</option>
				
				<option value="file6">github.com/tranm/gassigeher/internal/handlers/booking_handler.go (36.6%)</option>
				
				<option value="file7">github.com/tranm/gassigeher/internal/handlers/dashboard_handler.go (89.3%)</option>
				
				<option value="file8">github.com/tranm/gassigeher/internal/handlers/dog_handler.go (47.7%)</option>
				
				<option value="file9">github.com/tranm/gassigeher/internal/handlers/experience_request_handler.go (62.0%)</option>
				
				<option value="file10">github.com/tranm/gassigeher/internal/handlers/reactivation_request_handler.go (58.7%)</option>
				
				<option value="file11">github.com/tranm/gassigeher/internal/handlers/settings_handler.go (63.6%)</option>
				
				<option value="file12">github.com/tranm/gassigeher/internal/handlers/user_handler.go (32.7%)</option>
				
				<option value="file13">github.com/tranm/gassigeher/internal/middleware/middleware.go (91.2%)</option>
				
				<option value="file14">github.com/tranm/gassigeher/internal/models/blocked_date.go (100.0%)</option>
				
				<option value="file15">github.com/tranm/gassigeher/internal/models/booking.go (80.8%)</option>
				
				<option value="file16">github.com/tranm/gassigeher/internal/models/errors.go (100.0%)</option>
				
				<option value="file17">github.com/tranm/gassigeher/internal/models/experience_request.go (100.0%)</option>
				
				<option value="file18">github.com/tranm/gassigeher/internal/models/reactivation_request.go (100.0%)</option>
				
				<option value="file19">github.com/tranm/gassigeher/internal/models/settings.go (0.0%)</option>
				
				<option value="file20">github.com/tranm/gassigeher/internal/models/test_helpers.go (75.0%)</option>
				
				<option value="file21">github.com/tranm/gassigeher/internal/repository/blocked_date_repository.go (84.8%)</option>
				
				<option value="file22">github.com/tranm/gassigeher/internal/repository/booking_repository.go (54.5%)</option>
				
				<option value="file23">github.com/tranm/gassigeher/internal/repository/dog_repository.go (72.4%)</option>
				
				<option value="file24">github.com/tranm/gassigeher/internal/repository/experience_request_repository.go (84.6%)</option>
				
				<option value="file25">github.com/tranm/gassigeher/internal/repository/reactivation_request_repository.go (67.7%)</option>
				
				<option value="file26">github.com/tranm/gassigeher/internal/repository/settings_repository.go (84.4%)</option>
				
				<option value="file27">github.com/tranm/gassigeher/internal/repository/user_repository.go (69.6%)</option>
				
				<option value="file28">github.com/tranm/gassigeher/internal/services/auth_service.go (88.4%)</option>
				
				<option value="file29">github.com/tranm/gassigeher/internal/services/email_account.go (0.0%)</option>
				
				<option value="file30">github.com/tranm/gassigeher/internal/services/email_service.go (0.0%)</option>
				
				<option value="file31">github.com/tranm/gassigeher/internal/testutil/helpers.go (0.0%)</option>
				
				<option value="file32">github.com/tranm/gassigeher/scripts/genhash.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"
        "os"

        "github.com/gorilla/mux"
        "github.com/joho/godotenv"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/cron"
        "github.com/tranm/gassigeher/internal/database"
        "github.com/tranm/gassigeher/internal/handlers"
        "github.com/tranm/gassigeher/internal/middleware"
)

func main() <span class="cov0" title="0">{
        // Load environment variables
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Println("No .env file found, using environment variables")
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg := config.Load()

        // Initialize database
        db, err := database.Initialize(cfg.DatabasePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Run migrations
        if err := database.RunMigrations(db); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to run migrations: %v", err)
        }</span>

        // Initialize router
        <span class="cov0" title="0">router := mux.NewRouter()

        // Apply global middleware
        router.Use(middleware.LoggingMiddleware)
        router.Use(middleware.SecurityHeadersMiddleware)
        router.Use(middleware.CORSMiddleware)

        // Initialize handlers
        authHandler := handlers.NewAuthHandler(db, cfg)
        userHandler := handlers.NewUserHandler(db, cfg)
        dogHandler := handlers.NewDogHandler(db, cfg)
        bookingHandler := handlers.NewBookingHandler(db, cfg)
        blockedDateHandler := handlers.NewBlockedDateHandler(db, cfg)
        settingsHandler := handlers.NewSettingsHandler(db, cfg)
        experienceHandler := handlers.NewExperienceRequestHandler(db, cfg)
        reactivationHandler := handlers.NewReactivationRequestHandler(db, cfg)
        dashboardHandler := handlers.NewDashboardHandler(db, cfg)

        // Start cron service for auto-completion and reminders
        cronService := cron.NewCronService(db)
        cronService.Start()
        defer cronService.Stop()

        // Public routes
        router.HandleFunc("/api/auth/register", authHandler.Register).Methods("POST")
        router.HandleFunc("/api/auth/verify-email", authHandler.VerifyEmail).Methods("POST")
        router.HandleFunc("/api/auth/login", authHandler.Login).Methods("POST")
        router.HandleFunc("/api/auth/forgot-password", authHandler.ForgotPassword).Methods("POST")
        router.HandleFunc("/api/auth/reset-password", authHandler.ResetPassword).Methods("POST")

        // Reactivation request (public - for deactivated users)
        router.HandleFunc("/api/reactivation-requests", reactivationHandler.CreateRequest).Methods("POST")

        // Protected routes (authenticated users)
        protected := router.PathPrefix("/api").Subrouter()
        protected.Use(middleware.AuthMiddleware(cfg.JWTSecret))

        // Auth
        protected.HandleFunc("/auth/change-password", authHandler.ChangePassword).Methods("PUT")

        // Users
        protected.HandleFunc("/users/me", userHandler.GetMe).Methods("GET")
        protected.HandleFunc("/users/me", userHandler.UpdateMe).Methods("PUT")
        protected.HandleFunc("/users/me/photo", userHandler.UploadPhoto).Methods("POST")
        protected.HandleFunc("/users/me", userHandler.DeleteAccount).Methods("DELETE")

        // Dogs (read-only for authenticated users)
        protected.HandleFunc("/dogs", dogHandler.ListDogs).Methods("GET")
        protected.HandleFunc("/dogs/breeds", dogHandler.GetBreeds).Methods("GET")
        protected.HandleFunc("/dogs/{id}", dogHandler.GetDog).Methods("GET")

        // Bookings (authenticated users)
        protected.HandleFunc("/bookings", bookingHandler.ListBookings).Methods("GET")
        protected.HandleFunc("/bookings", bookingHandler.CreateBooking).Methods("POST")
        protected.HandleFunc("/bookings/{id}", bookingHandler.GetBooking).Methods("GET")
        protected.HandleFunc("/bookings/{id}/cancel", bookingHandler.CancelBooking).Methods("PUT")
        protected.HandleFunc("/bookings/{id}/notes", bookingHandler.AddNotes).Methods("PUT")
        protected.HandleFunc("/bookings/calendar/{year}/{month}", bookingHandler.GetCalendarData).Methods("GET")

        // Blocked dates (read-only for authenticated users)
        protected.HandleFunc("/blocked-dates", blockedDateHandler.ListBlockedDates).Methods("GET")

        // Experience requests (authenticated users)
        protected.HandleFunc("/experience-requests", experienceHandler.CreateRequest).Methods("POST")
        protected.HandleFunc("/experience-requests", experienceHandler.ListRequests).Methods("GET")

        // Admin-only routes
        admin := protected.PathPrefix("").Subrouter()
        admin.Use(middleware.RequireAdmin)

        // Dog management (admin only)
        admin.HandleFunc("/dogs", dogHandler.CreateDog).Methods("POST")
        admin.HandleFunc("/dogs/{id}", dogHandler.UpdateDog).Methods("PUT")
        admin.HandleFunc("/dogs/{id}", dogHandler.DeleteDog).Methods("DELETE")
        admin.HandleFunc("/dogs/{id}/photo", dogHandler.UploadDogPhoto).Methods("POST")
        admin.HandleFunc("/dogs/{id}/availability", dogHandler.ToggleAvailability).Methods("PUT")

        // Blocked dates management (admin only)
        admin.HandleFunc("/blocked-dates", blockedDateHandler.CreateBlockedDate).Methods("POST")
        admin.HandleFunc("/blocked-dates/{id}", blockedDateHandler.DeleteBlockedDate).Methods("DELETE")

        // Booking management (admin only)
        admin.HandleFunc("/bookings/{id}/move", bookingHandler.MoveBooking).Methods("PUT")

        // System settings (admin only)
        admin.HandleFunc("/settings", settingsHandler.GetAllSettings).Methods("GET")
        admin.HandleFunc("/settings/{key}", settingsHandler.UpdateSetting).Methods("PUT")

        // Experience requests management (admin only)
        admin.HandleFunc("/experience-requests/{id}/approve", experienceHandler.ApproveRequest).Methods("PUT")
        admin.HandleFunc("/experience-requests/{id}/deny", experienceHandler.DenyRequest).Methods("PUT")

        // User management (admin only)
        admin.HandleFunc("/users", userHandler.ListUsers).Methods("GET")
        admin.HandleFunc("/users/{id}", userHandler.GetUser).Methods("GET")
        admin.HandleFunc("/users/{id}/activate", userHandler.ActivateUser).Methods("PUT")
        admin.HandleFunc("/users/{id}/deactivate", userHandler.DeactivateUser).Methods("PUT")

        // Reactivation requests management (admin only)
        admin.HandleFunc("/reactivation-requests", reactivationHandler.ListRequests).Methods("GET")
        admin.HandleFunc("/reactivation-requests/{id}/approve", reactivationHandler.ApproveRequest).Methods("PUT")
        admin.HandleFunc("/reactivation-requests/{id}/deny", reactivationHandler.DenyRequest).Methods("PUT")

        // Admin dashboard (admin only)
        admin.HandleFunc("/admin/stats", dashboardHandler.GetStats).Methods("GET")
        admin.HandleFunc("/admin/activity", dashboardHandler.GetRecentActivity).Methods("GET")

        // Uploads directory (user photos, dog photos)
        router.PathPrefix("/uploads/").Handler(http.StripPrefix("/uploads/", http.FileServer(http.Dir("./uploads"))))

        // Static files
        router.PathPrefix("/").Handler(http.FileServer(http.Dir("./frontend")))

        // Start server
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">log.Printf("Server starting on port %s...", port)
        if err := http.ListenAndServe(":"+port, router); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"
        "strconv"
        "strings"
)

// Config holds the application configuration
type Config struct {
        // Database
        DatabasePath string

        // JWT
        JWTSecret          string
        JWTExpirationHours int

        // Admin
        AdminEmails []string

        // Gmail API
        GmailClientID     string
        GmailClientSecret string
        GmailRefreshToken string
        GmailFromEmail    string

        // Uploads
        UploadDir        string
        MaxUploadSizeMB  int

        // System Settings
        BookingAdvanceDays      int
        CancellationNoticeHours int
        AutoDeactivationDays    int

        // Server
        Port        string
        Environment string
}

// Load loads configuration from environment variables
func Load() *Config <span class="cov0" title="0">{
        return &amp;Config{
                // Database
                DatabasePath: getEnv("DATABASE_PATH", "./gassigeher.db"),

                // JWT
                JWTSecret:          getEnv("JWT_SECRET", "change-this-in-production"),
                JWTExpirationHours: getEnvAsInt("JWT_EXPIRATION_HOURS", 24),

                // Admin
                AdminEmails: getEnvAsSlice("ADMIN_EMAILS", ","),

                // Gmail API
                GmailClientID:     getEnv("GMAIL_CLIENT_ID", ""),
                GmailClientSecret: getEnv("GMAIL_CLIENT_SECRET", ""),
                GmailRefreshToken: getEnv("GMAIL_REFRESH_TOKEN", ""),
                GmailFromEmail:    getEnv("GMAIL_FROM_EMAIL", "noreply@gassigeher.com"),

                // Uploads
                UploadDir:       getEnv("UPLOAD_DIR", "./uploads"),
                MaxUploadSizeMB: getEnvAsInt("MAX_UPLOAD_SIZE_MB", 5),

                // System Settings
                BookingAdvanceDays:      getEnvAsInt("BOOKING_ADVANCE_DAYS", 14),
                CancellationNoticeHours: getEnvAsInt("CANCELLATION_NOTICE_HOURS", 12),
                AutoDeactivationDays:    getEnvAsInt("AUTO_DEACTIVATION_DAYS", 365),

                // Server
                Port:        getEnv("PORT", "8080"),
                Environment: getEnv("ENVIRONMENT", "development"),
        }
}</span>

// IsAdmin checks if the given email is an admin
func (c *Config) IsAdmin(email string) bool <span class="cov0" title="0">{
        email = strings.TrimSpace(strings.ToLower(email))
        for _, adminEmail := range c.AdminEmails </span><span class="cov0" title="0">{
                if strings.TrimSpace(strings.ToLower(adminEmail)) == email </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Helper functions

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        valueStr := os.Getenv(key)
        if value, err := strconv.Atoi(valueStr); err == nil </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsSlice(key, sep string) []string <span class="cov0" title="0">{
        valueStr := os.Getenv(key)
        if valueStr == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">return strings.Split(valueStr, sep)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cron

import (
        "database/sql"
        "log"
        "strconv"
        "time"

        "github.com/tranm/gassigeher/internal/repository"
)

// CronService handles scheduled tasks
type CronService struct {
        db           *sql.DB
        bookingRepo  *repository.BookingRepository
        userRepo     *repository.UserRepository
        settingsRepo *repository.SettingsRepository
        stopChan     chan bool
}

// NewCronService creates a new cron service
func NewCronService(db *sql.DB) *CronService <span class="cov10" title="3">{
        return &amp;CronService{
                db:           db,
                bookingRepo:  repository.NewBookingRepository(db),
                userRepo:     repository.NewUserRepository(db),
                settingsRepo: repository.NewSettingsRepository(db),
                stopChan:     make(chan bool),
        }
}</span>

// Start starts all cron jobs
func (s *CronService) Start() <span class="cov0" title="0">{
        log.Println("Starting cron service...")

        // Run auto-complete job every hour
        go s.runPeriodically("Auto-complete bookings", 1*time.Hour, s.autoCompleteBookings)

        // Run auto-deactivation job daily at 3am
        go s.runDaily("Auto-deactivate inactive users", 3, 0, s.autoDeactivateInactiveUsers)

        // Run booking reminder job every 15 minutes
        // Note: This is a placeholder for future implementation
        // go s.runPeriodically("Send booking reminders", 15*time.Minute, s.sendBookingReminders)
}</span>

// Stop stops all cron jobs
func (s *CronService) Stop() <span class="cov0" title="0">{
        log.Println("Stopping cron service...")
        close(s.stopChan)
}</span>

// runPeriodically runs a function periodically
func (s *CronService) runPeriodically(name string, interval time.Duration, fn func()) <span class="cov0" title="0">{
        // Run immediately on start
        fn()

        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        log.Printf("Running cron job: %s", name)
                        fn()</span>
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        log.Printf("Stopped cron job: %s", name)
                        return</span>
                }
        }
}

// autoCompleteBookings marks past scheduled bookings as completed
func (s *CronService) autoCompleteBookings() <span class="cov10" title="3">{
        count, err := s.bookingRepo.AutoComplete()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error auto-completing bookings: %v", err)
                return
        }</span>

        <span class="cov10" title="3">if count &gt; 0 </span><span class="cov1" title="1">{
                log.Printf("Auto-completed %d booking(s)", count)
        }</span>
}

// sendBookingReminders sends reminders for upcoming bookings
// This is a placeholder for future implementation
func (s *CronService) sendBookingReminders() <span class="cov0" title="0">{
        // Get bookings that need reminders (1 hour before)
        bookings, err := s.bookingRepo.GetForReminders()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting bookings for reminders: %v", err)
                return
        }</span>

        <span class="cov0" title="0">if len(bookings) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Found %d booking(s) that need reminders", len(bookings))</span>

        // TODO: Send reminder emails
        // This requires getting user and dog details, then sending email
        // Will be implemented when email reminder system is fully set up
}

// runDaily runs a function daily at a specific time
func (s *CronService) runDaily(name string, hour, minute int, fn func()) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                now := time.Now()
                next := time.Date(now.Year(), now.Month(), now.Day(), hour, minute, 0, 0, now.Location())
                
                // If we've passed today's scheduled time, schedule for tomorrow
                if now.After(next) </span><span class="cov0" title="0">{
                        next = next.Add(24 * time.Hour)
                }</span>

                <span class="cov0" title="0">duration := next.Sub(now)
                log.Printf("Scheduling daily job '%s' to run in %v (at %s)", name, duration, next.Format("2006-01-02 15:04:05"))

                select </span>{
                case &lt;-time.After(duration):<span class="cov0" title="0">
                        log.Printf("Running daily job: %s", name)
                        fn()</span>
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        log.Printf("Stopped daily job: %s", name)
                        return</span>
                }
        }
}

// autoDeactivateInactiveUsers deactivates users who haven't been active for the configured period
func (s *CronService) autoDeactivateInactiveUsers() <span class="cov10" title="3">{
        // Get deactivation period from settings
        setting, err := s.settingsRepo.Get("auto_deactivation_days")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting auto_deactivation_days setting: %v", err)
                return
        }</span>

        <span class="cov10" title="3">days := 365 // default 1 year
        if setting != nil </span><span class="cov10" title="3">{
                if d, err := strconv.Atoi(setting.Value); err == nil </span><span class="cov10" title="3">{
                        days = d
                }</span>
        }

        // Find inactive users
        <span class="cov10" title="3">users, err := s.userRepo.FindInactiveUsers(days)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding inactive users: %v", err)
                return
        }</span>

        <span class="cov10" title="3">if len(users) == 0 </span><span class="cov6" title="2">{
                log.Println("No inactive users to deactivate")
                return
        }</span>

        <span class="cov1" title="1">log.Printf("Found %d inactive user(s) to deactivate", len(users))

        // Deactivate each user
        for _, user := range users </span><span class="cov1" title="1">{
                if err := s.userRepo.Deactivate(user.ID, "auto_inactivity"); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error deactivating user %d: %v", user.ID, err)
                        continue</span>
                }

                <span class="cov1" title="1">log.Printf("Auto-deactivated user %d (inactive for %d days)", user.ID, days)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "database/sql"
        "fmt"

        _ "github.com/mattn/go-sqlite3"
)

// Initialize creates and opens the database connection
func Initialize(dbPath string) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Enable foreign keys
        <span class="cov0" title="0">if _, err := db.Exec("PRAGMA foreign_keys = ON"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
        }</span>

        // Test connection
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// RunMigrations runs all database migrations
func RunMigrations(db *sql.DB) error <span class="cov0" title="0">{
        migrations := []string{
                createUsersTable,
                createDogsTable,
                createBookingsTable,
                createBlockedDatesTable,
                createExperienceRequestsTable,
                createSystemSettingsTable,
                createReactivationRequestsTable,
                insertDefaultSettings,
        }

        for i, migration := range migrations </span><span class="cov0" title="0">{
                if _, err := db.Exec(migration); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration %d failed: %w", i+1, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

const createUsersTable = `
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT UNIQUE,
  phone TEXT,
  password_hash TEXT,
  experience_level TEXT DEFAULT 'green' CHECK(experience_level IN ('green', 'blue', 'orange')),
  is_verified INTEGER DEFAULT 0,
  is_active INTEGER DEFAULT 1,
  is_deleted INTEGER DEFAULT 0,
  verification_token TEXT,
  verification_token_expires TIMESTAMP,
  password_reset_token TEXT,
  password_reset_expires TIMESTAMP,
  profile_photo TEXT,
  anonymous_id TEXT UNIQUE,
  terms_accepted_at TIMESTAMP NOT NULL,
  last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  deactivated_at TIMESTAMP,
  deactivation_reason TEXT,
  reactivated_at TIMESTAMP,
  deleted_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_users_last_activity ON users(last_activity_at, is_active);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
`

const createDogsTable = `
CREATE TABLE IF NOT EXISTS dogs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  breed TEXT NOT NULL,
  size TEXT CHECK(size IN ('small', 'medium', 'large')),
  age INTEGER,
  category TEXT CHECK(category IN ('green', 'blue', 'orange')),
  photo TEXT,
  special_needs TEXT,
  pickup_location TEXT,
  walk_route TEXT,
  walk_duration INTEGER,
  special_instructions TEXT,
  default_morning_time TEXT,
  default_evening_time TEXT,
  is_available INTEGER DEFAULT 1,
  unavailable_reason TEXT,
  unavailable_since TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_dogs_available ON dogs(is_available, category);
`

const createBookingsTable = `
CREATE TABLE IF NOT EXISTS bookings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  dog_id INTEGER NOT NULL,
  date DATE NOT NULL,
  walk_type TEXT CHECK(walk_type IN ('morning', 'evening')),
  scheduled_time TEXT NOT NULL,
  status TEXT DEFAULT 'scheduled' CHECK(status IN ('scheduled', 'completed', 'cancelled')),
  completed_at TIMESTAMP,
  user_notes TEXT,
  admin_cancellation_reason TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (dog_id) REFERENCES dogs(id) ON DELETE CASCADE,
  UNIQUE(dog_id, date, walk_type)
);
`

const createBlockedDatesTable = `
CREATE TABLE IF NOT EXISTS blocked_dates (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  date DATE NOT NULL UNIQUE,
  reason TEXT NOT NULL,
  created_by INTEGER NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (created_by) REFERENCES users(id)
);
`

const createExperienceRequestsTable = `
CREATE TABLE IF NOT EXISTS experience_requests (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  requested_level TEXT CHECK(requested_level IN ('blue', 'orange')),
  status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'approved', 'denied')),
  admin_message TEXT,
  reviewed_by INTEGER,
  reviewed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (reviewed_by) REFERENCES users(id)
);
`

const createSystemSettingsTable = `
CREATE TABLE IF NOT EXISTS system_settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
`

const createReactivationRequestsTable = `
CREATE TABLE IF NOT EXISTS reactivation_requests (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'approved', 'denied')),
  admin_message TEXT,
  reviewed_by INTEGER,
  reviewed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (reviewed_by) REFERENCES users(id)
);

CREATE INDEX IF NOT EXISTS idx_reactivation_pending ON reactivation_requests(status, created_at);
`

const insertDefaultSettings = `
INSERT OR IGNORE INTO system_settings (key, value) VALUES
  ('booking_advance_days', '14'),
  ('cancellation_notice_hours', '12'),
  ('auto_deactivation_days', '365');
`
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/middleware"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
        "github.com/tranm/gassigeher/internal/services"
)

// AuthHandler handles authentication endpoints
type AuthHandler struct {
        userRepo     *repository.UserRepository
        authService  *services.AuthService
        emailService *services.EmailService
        config       *config.Config
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(db *sql.DB, cfg *config.Config) *AuthHandler <span class="cov3" title="4">{
        emailService, err := services.NewEmailService(
                cfg.GmailClientID,
                cfg.GmailClientSecret,
                cfg.GmailRefreshToken,
                cfg.GmailFromEmail,
        )
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - emails will fail gracefully
                fmt.Printf("Warning: Failed to initialize email service: %v\n", err)
        }</span>

        <span class="cov3" title="4">return &amp;AuthHandler{
                userRepo:     repository.NewUserRepository(db),
                authService:  services.NewAuthService(cfg.JWTSecret, cfg.JWTExpirationHours),
                emailService: emailService,
                config:       cfg,
        }</span>
}

// Register handles user registration
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov5" title="8">{
        var req models.RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate input
        <span class="cov5" title="8">if strings.TrimSpace(req.Name) == "" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Name is required")
                return
        }</span>
        <span class="cov4" title="7">if strings.TrimSpace(req.Email) == "" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Email is required")
                return
        }</span>
        <span class="cov4" title="6">if strings.TrimSpace(req.Phone) == "" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Phone is required")
                return
        }</span>
        <span class="cov4" title="5">if req.Password != req.ConfirmPassword </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Passwords do not match")
                return
        }</span>
        <span class="cov3" title="4">if !req.AcceptTerms </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "You must accept the terms and conditions")
                return
        }</span>

        // Validate password strength
        <span class="cov3" title="3">if err := h.authService.ValidatePassword(req.Password); err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Check if user already exists
        <span class="cov2" title="2">existing, err := h.userRepo.FindByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov2" title="2">if existing != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusConflict, "Email already registered")
                return
        }</span>

        // Hash password
        <span class="cov1" title="1">passwordHash, err := h.authService.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to hash password")
                return
        }</span>

        // Generate verification token
        <span class="cov1" title="1">verificationToken, err := h.authService.GenerateToken()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to generate verification token")
                return
        }</span>

        <span class="cov1" title="1">expires := time.Now().Add(24 * time.Hour)

        // Create user
        user := &amp;models.User{
                Name:                     req.Name,
                Email:                    &amp;req.Email,
                Phone:                    &amp;req.Phone,
                PasswordHash:             &amp;passwordHash,
                ExperienceLevel:          "green",
                IsVerified:               false,
                IsActive:                 true,
                IsDeleted:                false,
                VerificationToken:        &amp;verificationToken,
                VerificationTokenExpires: &amp;expires,
                TermsAcceptedAt:          time.Now(),
                LastActivityAt:           time.Now(),
        }

        if err := h.userRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create user")
                return
        }</span>

        // Send verification email
        <span class="cov1" title="1">if h.emailService != nil </span><span class="cov1" title="1">{
                if err := h.emailService.SendVerificationEmail(req.Email, req.Name, verificationToken); err != nil </span><span class="cov1" title="1">{
                        fmt.Printf("Failed to send verification email: %v\n", err)
                        // Don't fail the registration if email fails
                }</span>
        }

        <span class="cov1" title="1">respondJSON(w, http.StatusCreated, map[string]interface{}{
                "message": "Registration successful. Please check your email to verify your account.",
                "user_id": user.ID,
        })</span>
}

// VerifyEmail handles email verification
func (h *AuthHandler) VerifyEmail(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        var req models.VerifyEmailRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov3" title="3">if strings.TrimSpace(req.Token) == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Token is required")
                return
        }</span>

        // Find user by token
        <span class="cov3" title="3">user, err := h.userRepo.FindByVerificationToken(req.Token)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov3" title="3">if user == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "Invalid or expired verification token")
                return
        }</span>

        // Check if already verified
        <span class="cov2" title="2">if user.IsVerified </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Email already verified")
                return
        }</span>

        // Check if token expired
        <span class="cov2" title="2">if user.VerificationTokenExpires != nil &amp;&amp; time.Now().After(*user.VerificationTokenExpires) </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Verification token expired")
                return
        }</span>

        // Mark as verified
        <span class="cov1" title="1">user.IsVerified = true
        user.VerificationToken = nil
        user.VerificationTokenExpires = nil

        if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to verify user")
                return
        }</span>

        // Send welcome email
        <span class="cov1" title="1">if h.emailService != nil &amp;&amp; user.Email != nil </span><span class="cov1" title="1">{
                if err := h.emailService.SendWelcomeEmail(*user.Email, user.Name); err != nil </span><span class="cov1" title="1">{
                        fmt.Printf("Failed to send welcome email: %v\n", err)
                }</span>
        }

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{
                "message": "Email verified successfully. You can now login.",
        })</span>
}

// Login handles user login
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov4" title="6">{
        var req models.LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov4" title="5">if strings.TrimSpace(req.Email) == "" || strings.TrimSpace(req.Password) == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Email and password are required")
                return
        }</span>

        // Find user
        <span class="cov4" title="5">user, err := h.userRepo.FindByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov4" title="5">if user == nil || user.PasswordHash == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusUnauthorized, "Invalid credentials")
                return
        }</span>

        // Check password
        <span class="cov3" title="4">if !h.authService.CheckPassword(req.Password, *user.PasswordHash) </span><span class="cov1" title="1">{
                respondError(w, http.StatusUnauthorized, "Invalid credentials")
                return
        }</span>

        // Check if verified
        <span class="cov3" title="3">if !user.IsVerified </span><span class="cov1" title="1">{
                respondError(w, http.StatusForbidden, "Please verify your email before logging in")
                return
        }</span>

        // Check if active
        <span class="cov2" title="2">if !user.IsActive </span><span class="cov1" title="1">{
                respondError(w, http.StatusForbidden, "Your account has been deactivated. Please contact support for reactivation.")
                return
        }</span>

        // Update last activity
        <span class="cov1" title="1">if err := h.userRepo.UpdateLastActivity(user.ID); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update last activity: %v\n", err)
        }</span>

        // Check if admin
        <span class="cov1" title="1">isAdmin := h.config.IsAdmin(req.Email)

        // Generate JWT
        token, err := h.authService.GenerateJWT(user.ID, req.Email, isAdmin)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to generate token")
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, models.LoginResponse{
                Token:   token,
                User:    user,
                IsAdmin: isAdmin,
        })</span>
}

// ForgotPassword handles password reset request
func (h *AuthHandler) ForgotPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.ForgotPasswordRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(req.Email) == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Email is required")
                return
        }</span>

        // Find user
        <span class="cov0" title="0">user, err := h.userRepo.FindByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>

        // Always return success even if user doesn't exist (security)
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                respondJSON(w, http.StatusOK, map[string]string{
                        "message": "If an account exists with this email, you will receive a password reset link.",
                })
                return
        }</span>

        // Generate reset token
        <span class="cov0" title="0">resetToken, err := h.authService.GenerateToken()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to generate reset token")
                return
        }</span>

        <span class="cov0" title="0">expires := time.Now().Add(1 * time.Hour)
        user.PasswordResetToken = &amp;resetToken
        user.PasswordResetExpires = &amp;expires

        if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to save reset token")
                return
        }</span>

        // Send reset email
        <span class="cov0" title="0">if h.emailService != nil &amp;&amp; user.Email != nil </span><span class="cov0" title="0">{
                if err := h.emailService.SendPasswordResetEmail(*user.Email, user.Name, resetToken); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to send password reset email: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{
                "message": "If an account exists with this email, you will receive a password reset link.",
        })</span>
}

// ResetPassword handles password reset with token
func (h *AuthHandler) ResetPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.ResetPasswordRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(req.Token) == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Token is required")
                return
        }</span>

        <span class="cov0" title="0">if req.Password != req.ConfirmPassword </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Passwords do not match")
                return
        }</span>

        // Validate password
        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Find user by token
        <span class="cov0" title="0">user, err := h.userRepo.FindByPasswordResetToken(req.Token)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Invalid or expired reset token")
                return
        }</span>

        // Check if token expired
        <span class="cov0" title="0">if user.PasswordResetExpires != nil &amp;&amp; time.Now().After(*user.PasswordResetExpires) </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Reset token expired")
                return
        }</span>

        // Hash new password
        <span class="cov0" title="0">passwordHash, err := h.authService.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to hash password")
                return
        }</span>

        // Update password and clear token
        <span class="cov0" title="0">user.PasswordHash = &amp;passwordHash
        user.PasswordResetToken = nil
        user.PasswordResetExpires = nil

        if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update password")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{
                "message": "Password reset successful. You can now login with your new password.",
        })</span>
}

// ChangePassword handles password change for logged-in users
func (h *AuthHandler) ChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov3" title="4">{
        userID, ok := r.Context().Value(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov3" title="4">var req models.ChangePasswordRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov3" title="4">if req.NewPassword != req.ConfirmPassword </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Passwords do not match")
                return
        }</span>

        // Validate new password
        <span class="cov3" title="3">if err := h.authService.ValidatePassword(req.NewPassword); err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get user
        <span class="cov2" title="2">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov2" title="2">if user == nil || user.PasswordHash == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Verify old password
        <span class="cov2" title="2">if !h.authService.CheckPassword(req.OldPassword, *user.PasswordHash) </span><span class="cov1" title="1">{
                respondError(w, http.StatusUnauthorized, "Incorrect old password")
                return
        }</span>

        // Hash new password
        <span class="cov1" title="1">newHash, err := h.authService.HashPassword(req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to hash password")
                return
        }</span>

        <span class="cov1" title="1">user.PasswordHash = &amp;newHash
        if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update password")
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{
                "message": "Password changed successfully",
        })</span>
}

// Helper functions

func respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov10" title="96">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func respondError(w http.ResponseWriter, status int, message string) <span class="cov8" title="45">{
        respondJSON(w, status, map[string]string{"error": message})
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
)

// BlockedDateHandler handles blocked date-related HTTP requests
type BlockedDateHandler struct {
        db              *sql.DB
        cfg             *config.Config
        blockedDateRepo *repository.BlockedDateRepository
}

// NewBlockedDateHandler creates a new blocked date handler
func NewBlockedDateHandler(db *sql.DB, cfg *config.Config) *BlockedDateHandler <span class="cov8" title="4">{
        return &amp;BlockedDateHandler{
                db:              db,
                cfg:             cfg,
                blockedDateRepo: repository.NewBlockedDateRepository(db),
        }
}</span>

// ListBlockedDates lists all blocked dates
func (h *BlockedDateHandler) ListBlockedDates(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        blockedDates, err := h.blockedDateRepo.FindAll()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get blocked dates")
                return
        }</span>

        <span class="cov4" title="2">respondJSON(w, http.StatusOK, blockedDates)</span>
}

// CreateBlockedDate creates a new blocked date (admin only)
func (h *BlockedDateHandler) CreateBlockedDate(w http.ResponseWriter, r *http.Request) <span class="cov10" title="5">{
        // Get admin user ID from context
        userID, _ := r.Context().Value("user_id").(int)

        // Parse request
        var req models.CreateBlockedDateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate request
        <span class="cov10" title="5">if err := req.Validate(); err != nil </span><span class="cov4" title="2">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Create blocked date
        <span class="cov7" title="3">blockedDate := &amp;models.BlockedDate{
                Date:      req.Date,
                Reason:    req.Reason,
                CreatedBy: userID,
        }

        if err := h.blockedDateRepo.Create(blockedDate); err != nil </span><span class="cov1" title="1">{
                if err.Error() == "date is already blocked" </span><span class="cov1" title="1">{
                        respondError(w, http.StatusConflict, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(w, http.StatusInternalServerError, "Failed to create blocked date")
                return</span>
        }

        <span class="cov4" title="2">respondJSON(w, http.StatusCreated, blockedDate)</span>
}

// DeleteBlockedDate deletes a blocked date (admin only)
func (h *BlockedDateHandler) DeleteBlockedDate(w http.ResponseWriter, r *http.Request) <span class="cov7" title="3">{
        // Get ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Invalid blocked date ID")
                return
        }</span>

        // Delete blocked date
        <span class="cov4" title="2">if err := h.blockedDateRepo.Delete(id); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to delete blocked date")
                return
        }</span>

        <span class="cov4" title="2">respondJSON(w, http.StatusOK, map[string]string{"message": "Blocked date deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
        "github.com/tranm/gassigeher/internal/services"
)

// BookingHandler handles booking-related HTTP requests
type BookingHandler struct {
        db                   *sql.DB
        cfg                  *config.Config
        bookingRepo          *repository.BookingRepository
        dogRepo              *repository.DogRepository
        userRepo             *repository.UserRepository
        blockedDateRepo      *repository.BlockedDateRepository
        settingsRepo         *repository.SettingsRepository
        emailService         *services.EmailService
}

// NewBookingHandler creates a new booking handler
func NewBookingHandler(db *sql.DB, cfg *config.Config) *BookingHandler <span class="cov7" title="4">{
        emailService, err := services.NewEmailService(
                cfg.GmailClientID,
                cfg.GmailClientSecret,
                cfg.GmailRefreshToken,
                cfg.GmailFromEmail,
        )
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - emails will fail gracefully
                fmt.Printf("Warning: Failed to initialize email service: %v\n", err)
        }</span>

        <span class="cov7" title="4">return &amp;BookingHandler{
                db:                   db,
                cfg:                  cfg,
                bookingRepo:          repository.NewBookingRepository(db),
                dogRepo:              repository.NewDogRepository(db),
                userRepo:             repository.NewUserRepository(db),
                blockedDateRepo:      repository.NewBlockedDateRepository(db),
                settingsRepo:         repository.NewSettingsRepository(db),
                emailService:         emailService,
        }</span>
}

// CreateBooking creates a new booking
func (h *BookingHandler) CreateBooking(w http.ResponseWriter, r *http.Request) <span class="cov10" title="7">{
        // Get user ID from context
        userID, ok := r.Context().Value("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Parse request
        <span class="cov10" title="7">var req models.CreateBookingRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate request
        <span class="cov10" title="7">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get user to check experience level
        <span class="cov9" title="6">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get user")
                return
        }</span>
        <span class="cov9" title="6">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Check if user is active
        <span class="cov9" title="6">if !user.IsActive </span><span class="cov1" title="1">{
                respondError(w, http.StatusForbidden, "Your account is deactivated")
                return
        }</span>

        // Get dog
        <span class="cov8" title="5">dog, err := h.dogRepo.FindByID(req.DogID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get dog")
                return
        }</span>
        <span class="cov8" title="5">if dog == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Dog not found")
                return
        }</span>

        // Check if dog is available
        <span class="cov8" title="5">if !dog.IsAvailable </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Dog is currently unavailable")
                return
        }</span>

        // Check experience level access
        <span class="cov8" title="5">if !repository.CanUserAccessDog(user.ExperienceLevel, dog.Category) </span><span class="cov1" title="1">{
                respondError(w, http.StatusForbidden, "You don't have the required experience level for this dog")
                return
        }</span>

        // Check if date is in the past
        <span class="cov7" title="4">bookingDate, _ := time.Parse("2006-01-02", req.Date)
        today := time.Now().Truncate(24 * time.Hour)
        if bookingDate.Before(today) </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Cannot book dates in the past")
                return
        }</span>

        // Check booking advance limit
        <span class="cov6" title="3">advanceSetting, err := h.settingsRepo.Get("booking_advance_days")
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get settings")
                return
        }</span>
        <span class="cov6" title="3">advanceDays := 14 // default
        if advanceSetting != nil </span><span class="cov6" title="3">{
                advanceDays, _ = strconv.Atoi(advanceSetting.Value)
        }</span>
        <span class="cov6" title="3">maxDate := today.AddDate(0, 0, advanceDays)
        if bookingDate.After(maxDate) </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, fmt.Sprintf("Cannot book more than %d days in advance", advanceDays))
                return
        }</span>

        // Check if date is blocked
        <span class="cov6" title="3">isBlocked, err := h.blockedDateRepo.IsBlocked(req.Date)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to check blocked dates")
                return
        }</span>
        <span class="cov6" title="3">if isBlocked </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "This date is blocked")
                return
        }</span>

        // Check for double-booking
        <span class="cov4" title="2">isDoubleBooked, err := h.bookingRepo.CheckDoubleBooking(req.DogID, req.Date, req.WalkType)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to check availability")
                return
        }</span>
        <span class="cov4" title="2">if isDoubleBooked </span><span class="cov1" title="1">{
                respondError(w, http.StatusConflict, "This dog is already booked for this time")
                return
        }</span>

        // Create booking
        <span class="cov1" title="1">booking := &amp;models.Booking{
                UserID:        userID,
                DogID:         req.DogID,
                Date:          req.Date,
                WalkType:      req.WalkType,
                ScheduledTime: req.ScheduledTime,
        }

        if err := h.bookingRepo.Create(booking); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create booking")
                return
        }</span>

        // Update user last activity
        <span class="cov1" title="1">h.userRepo.UpdateLastActivity(userID)

        // Send confirmation email
        if user.Email != nil </span><span class="cov1" title="1">{
                go h.emailService.SendBookingConfirmation(*user.Email, user.Name, dog.Name, booking.Date, booking.WalkType, booking.ScheduledTime)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusCreated, booking)</span>
}

// ListBookings lists bookings
func (h *BookingHandler) ListBookings(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        // Get user ID and admin status from context
        userID, _ := r.Context().Value("user_id").(int)
        isAdmin, _ := r.Context().Value("is_admin").(bool)

        // Parse query parameters
        filter := &amp;models.BookingFilterRequest{}

        if dogIDStr := r.URL.Query().Get("dog_id"); dogIDStr != "" </span><span class="cov0" title="0">{
                dogID, _ := strconv.Atoi(dogIDStr)
                filter.DogID = &amp;dogID
        }</span>

        <span class="cov4" title="2">if dateFrom := r.URL.Query().Get("date_from"); dateFrom != "" </span><span class="cov0" title="0">{
                filter.DateFrom = &amp;dateFrom
        }</span>

        <span class="cov4" title="2">if dateTo := r.URL.Query().Get("date_to"); dateTo != "" </span><span class="cov0" title="0">{
                filter.DateTo = &amp;dateTo
        }</span>

        <span class="cov4" title="2">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filter.Status = &amp;status
        }</span>

        <span class="cov4" title="2">if walkType := r.URL.Query().Get("walk_type"); walkType != "" </span><span class="cov0" title="0">{
                filter.WalkType = &amp;walkType
        }</span>

        // Non-admins can only see their own bookings
        <span class="cov4" title="2">if !isAdmin </span><span class="cov4" title="2">{
                filter.UserID = &amp;userID
        }</span> else<span class="cov0" title="0"> if userIDStr := r.URL.Query().Get("user_id"); userIDStr != "" </span><span class="cov0" title="0">{
                uid, _ := strconv.Atoi(userIDStr)
                filter.UserID = &amp;uid
        }</span>

        // Get bookings
        <span class="cov4" title="2">bookings, err := h.bookingRepo.FindAll(filter)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get bookings")
                return
        }</span>

        <span class="cov4" title="2">respondJSON(w, http.StatusOK, bookings)</span>
}

// GetBooking gets a booking by ID
func (h *BookingHandler) GetBooking(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get booking ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid booking ID")
                return
        }</span>

        // Get user ID and admin status
        <span class="cov0" title="0">userID, _ := r.Context().Value("user_id").(int)
        isAdmin, _ := r.Context().Value("is_admin").(bool)

        // Get booking
        booking, err := h.bookingRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get booking")
                return
        }</span>
        <span class="cov0" title="0">if booking == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Booking not found")
                return
        }</span>

        // Check authorization (user can only see their own bookings)
        <span class="cov0" title="0">if !isAdmin &amp;&amp; booking.UserID != userID </span><span class="cov0" title="0">{
                respondError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, booking)</span>
}

// CancelBooking cancels a booking
func (h *BookingHandler) CancelBooking(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        // Get booking ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid booking ID")
                return
        }</span>

        // Get user ID and admin status
        <span class="cov6" title="3">userID, _ := r.Context().Value("user_id").(int)
        isAdmin, _ := r.Context().Value("is_admin").(bool)

        // Parse request
        var req models.CancelBookingRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov6" title="3">{
                // Allow empty body
                req = models.CancelBookingRequest{}
        }</span>

        // Get booking
        <span class="cov6" title="3">booking, err := h.bookingRepo.FindByIDWithDetails(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get booking")
                return
        }</span>
        <span class="cov6" title="3">if booking == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "Booking not found")
                return
        }</span>

        // Check authorization
        <span class="cov4" title="2">if !isAdmin &amp;&amp; booking.UserID != userID </span><span class="cov1" title="1">{
                respondError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        // Check if already cancelled or completed
        <span class="cov1" title="1">if booking.Status != "scheduled" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Booking is already "+booking.Status)
                return
        }</span>

        // For non-admin users, check cancellation notice period
        <span class="cov1" title="1">if !isAdmin </span><span class="cov0" title="0">{
                noticeSetting, err := h.settingsRepo.Get("cancellation_notice_hours")
                if err != nil </span><span class="cov0" title="0">{
                        respondError(w, http.StatusInternalServerError, "Failed to get settings")
                        return
                }</span>
                <span class="cov0" title="0">noticeHours := 12 // default
                if noticeSetting != nil </span><span class="cov0" title="0">{
                        noticeHours, _ = strconv.Atoi(noticeSetting.Value)
                }</span>

                // Parse booking date and time
                <span class="cov0" title="0">bookingDateTime := booking.Date + " " + booking.ScheduledTime
                bookingTime, _ := time.Parse("2006-01-02 15:04", bookingDateTime)
                now := time.Now()
                hoursUntilBooking := bookingTime.Sub(now).Hours()

                if hoursUntilBooking &lt; float64(noticeHours) </span><span class="cov0" title="0">{
                        respondError(w, http.StatusBadRequest, fmt.Sprintf("Bookings must be cancelled at least %d hours in advance", noticeHours))
                        return
                }</span>
        }

        // Cancel booking
        <span class="cov1" title="1">if err := h.bookingRepo.Cancel(id, req.Reason); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to cancel booking")
                return
        }</span>

        // Update user last activity
        <span class="cov1" title="1">h.userRepo.UpdateLastActivity(userID)

        // Send cancellation email
        if booking.User.Email != nil </span><span class="cov1" title="1">{
                if isAdmin &amp;&amp; req.Reason != nil </span><span class="cov0" title="0">{
                        // Admin cancelled
                        go h.emailService.SendAdminCancellation(*booking.User.Email, booking.User.Name, booking.Dog.Name, booking.Date, booking.WalkType, *req.Reason)
                }</span> else<span class="cov1" title="1"> {
                        // User cancelled
                        go h.emailService.SendBookingCancellation(*booking.User.Email, booking.User.Name, booking.Dog.Name, booking.Date, booking.WalkType)
                }</span>
        }

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Booking cancelled successfully"})</span>
}

// AddNotes adds notes to a completed booking
func (h *BookingHandler) AddNotes(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        // Get booking ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid booking ID")
                return
        }</span>

        // Get user ID
        <span class="cov4" title="2">userID, _ := r.Context().Value("user_id").(int)

        // Parse request
        var req models.AddNotesRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov4" title="2">if req.Notes == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Notes cannot be empty")
                return
        }</span>

        // Get booking
        <span class="cov4" title="2">booking, err := h.bookingRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get booking")
                return
        }</span>
        <span class="cov4" title="2">if booking == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Booking not found")
                return
        }</span>

        // Check authorization
        <span class="cov4" title="2">if booking.UserID != userID </span><span class="cov0" title="0">{
                respondError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        // Check if booking is completed
        <span class="cov4" title="2">if booking.Status != "completed" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Can only add notes to completed bookings")
                return
        }</span>

        // Add notes
        <span class="cov1" title="1">if err := h.bookingRepo.AddNotes(id, req.Notes); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Notes added successfully"})</span>
}

// MoveBooking moves a booking to a new date/time (admin only)
func (h *BookingHandler) MoveBooking(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get booking ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid booking ID")
                return
        }</span>

        // Get admin user ID
        <span class="cov0" title="0">userID, _ := r.Context().Value("user_id").(int)

        // Parse request
        var req models.MoveBookingRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get booking with details
        <span class="cov0" title="0">booking, err := h.bookingRepo.FindByIDWithDetails(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get booking")
                return
        }</span>
        <span class="cov0" title="0">if booking == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Booking not found")
                return
        }</span>

        // Check if booking can be moved (only scheduled bookings)
        <span class="cov0" title="0">if booking.Status != "scheduled" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Can only move scheduled bookings")
                return
        }</span>

        // Store old values for email
        <span class="cov0" title="0">oldDate := booking.Date
        oldWalkType := booking.WalkType
        oldTime := booking.ScheduledTime

        // Check if new date is blocked
        isBlocked, err := h.blockedDateRepo.IsBlocked(req.Date)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to check blocked dates")
                return
        }</span>
        <span class="cov0" title="0">if isBlocked </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "The new date is blocked")
                return
        }</span>

        // Check for double-booking at new time
        <span class="cov0" title="0">isDoubleBooked, err := h.bookingRepo.CheckDoubleBooking(booking.DogID, req.Date, req.WalkType)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to check availability")
                return
        }</span>
        <span class="cov0" title="0">if isDoubleBooked </span><span class="cov0" title="0">{
                respondError(w, http.StatusConflict, "Dog is already booked for this time")
                return
        }</span>

        // Update booking
        <span class="cov0" title="0">booking.Date = req.Date
        booking.WalkType = req.WalkType
        booking.ScheduledTime = req.ScheduledTime

        if err := h.bookingRepo.Update(booking); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to move booking")
                return
        }</span>

        // Update user last activity
        <span class="cov0" title="0">h.userRepo.UpdateLastActivity(userID)

        // Send email notification to user
        if booking.User.Email != nil </span><span class="cov0" title="0">{
                go h.emailService.SendBookingMoved(
                        *booking.User.Email,
                        booking.User.Name,
                        booking.Dog.Name,
                        oldDate,
                        oldWalkType,
                        oldTime,
                        req.Date,
                        req.WalkType,
                        req.ScheduledTime,
                        req.Reason,
                )
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "Booking moved successfully"})</span>
}

// GetCalendarData gets calendar data for a specific month
func (h *BookingHandler) GetCalendarData(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get year and month from URL
        vars := mux.Vars(r)
        year, err := strconv.Atoi(vars["year"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid year")
                return
        }</span>
        <span class="cov0" title="0">month, err := strconv.Atoi(vars["month"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid month")
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, _ := r.Context().Value("user_id").(int)

        // Get bookings for the month
        filter := &amp;models.BookingFilterRequest{
                UserID: &amp;userID,
                Year:   &amp;year,
                Month:  &amp;month,
        }
        bookings, err := h.bookingRepo.FindAll(filter)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get bookings")
                return
        }</span>

        // Get blocked dates
        <span class="cov0" title="0">blockedDates, err := h.blockedDateRepo.FindAll()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get blocked dates")
                return
        }</span>

        // Build calendar response
        // Get first and last day of month
        <span class="cov0" title="0">firstDay := time.Date(year, time.Month(month), 1, 0, 0, 0, 0, time.UTC)
        lastDay := firstDay.AddDate(0, 1, -1)

        // Create a map of bookings by date
        bookingsByDate := make(map[string][]*models.Booking)
        for _, booking := range bookings </span><span class="cov0" title="0">{
                bookingsByDate[booking.Date] = append(bookingsByDate[booking.Date], booking)
        }</span>

        // Create a map of blocked dates
        <span class="cov0" title="0">blockedByDate := make(map[string]*models.BlockedDate)
        for _, blocked := range blockedDates </span><span class="cov0" title="0">{
                blockedByDate[blocked.Date] = blocked
        }</span>

        // Build days array
        <span class="cov0" title="0">days := []*models.CalendarDay{}
        for d := firstDay; !d.After(lastDay); d = d.AddDate(0, 0, 1) </span><span class="cov0" title="0">{
                dateStr := d.Format("2006-01-02")
                day := &amp;models.CalendarDay{
                        Date:     dateStr,
                        Bookings: bookingsByDate[dateStr],
                }

                if blocked, ok := blockedByDate[dateStr]; ok </span><span class="cov0" title="0">{
                        day.IsBlocked = true
                        day.BlockedReason = &amp;blocked.Reason
                }</span>

                <span class="cov0" title="0">if day.Bookings == nil </span><span class="cov0" title="0">{
                        day.Bookings = []*models.Booking{}
                }</span>

                <span class="cov0" title="0">days = append(days, day)</span>
        }

        <span class="cov0" title="0">response := &amp;models.CalendarResponse{
                Year:  year,
                Month: month,
                Days:  days,
        }

        respondJSON(w, http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
)

// DashboardHandler handles admin dashboard endpoints
type DashboardHandler struct {
        db                   *sql.DB
        cfg                  *config.Config
        bookingRepo          *repository.BookingRepository
        userRepo             *repository.UserRepository
        dogRepo              *repository.DogRepository
        experienceRepo       *repository.ExperienceRequestRepository
        reactivationRepo     *repository.ReactivationRequestRepository
}

// NewDashboardHandler creates a new dashboard handler
func NewDashboardHandler(db *sql.DB, cfg *config.Config) *DashboardHandler <span class="cov5" title="2">{
        return &amp;DashboardHandler{
                db:               db,
                cfg:              cfg,
                bookingRepo:      repository.NewBookingRepository(db),
                userRepo:         repository.NewUserRepository(db),
                dogRepo:          repository.NewDogRepository(db),
                experienceRepo:   repository.NewExperienceRequestRepository(db),
                reactivationRepo: repository.NewReactivationRequestRepository(db),
        }
}</span>

// GetStats returns dashboard statistics (admin only)
func (h *DashboardHandler) GetStats(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        stats := &amp;models.DashboardStats{}

        // Get total completed walks
        completedBookings, err := h.bookingRepo.FindAll(&amp;models.BookingFilterRequest{
                Status: strPtr("completed"),
        })
        if err == nil </span><span class="cov1" title="1">{
                stats.TotalWalksCompleted = len(completedBookings)
        }</span>

        // Get upcoming walks
        <span class="cov1" title="1">today := time.Now().Format("2006-01-02")
        upcomingBookings, err := h.bookingRepo.FindAll(&amp;models.BookingFilterRequest{
                Status:   strPtr("scheduled"),
                DateFrom: &amp;today,
        })
        if err == nil </span><span class="cov1" title="1">{
                stats.UpcomingWalksTotal = len(upcomingBookings)

                // Count today's walks
                for _, booking := range upcomingBookings </span><span class="cov5" title="2">{
                        if booking.Date == today </span><span class="cov0" title="0">{
                                stats.UpcomingWalksToday++
                        }</span>
                }
        }

        // Get active/inactive users
        <span class="cov1" title="1">activeUsers, err := h.userRepo.FindAll(boolPtr(true))
        if err == nil </span><span class="cov1" title="1">{
                stats.ActiveUsers = len(activeUsers)
        }</span>

        <span class="cov1" title="1">inactiveUsers, err := h.userRepo.FindAll(boolPtr(false))
        if err == nil </span><span class="cov1" title="1">{
                stats.InactiveUsers = len(inactiveUsers)
        }</span>

        // Get available/unavailable dogs
        <span class="cov1" title="1">availableDogs, err := h.dogRepo.FindAll(&amp;models.DogFilterRequest{
                Available: boolPtr(true),
        })
        if err == nil </span><span class="cov1" title="1">{
                stats.AvailableDogs = len(availableDogs)
        }</span>

        <span class="cov1" title="1">unavailableDogs, err := h.dogRepo.FindAll(&amp;models.DogFilterRequest{
                Available: boolPtr(false),
        })
        if err == nil </span><span class="cov1" title="1">{
                stats.UnavailableDogs = len(unavailableDogs)
        }</span>

        // Get pending experience requests
        <span class="cov1" title="1">pendingExperienceReqs, err := h.experienceRepo.FindAllPending()
        if err == nil </span><span class="cov1" title="1">{
                stats.PendingExperienceReqs = len(pendingExperienceReqs)
        }</span>

        // Get pending reactivation requests
        <span class="cov1" title="1">pendingReactivationReqs, err := h.reactivationRepo.FindAllPending()
        if err == nil </span><span class="cov1" title="1">{
                stats.PendingReactivationReqs = len(pendingReactivationReqs)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, stats)</span>
}

// GetRecentActivity returns recent activity feed (admin only)
func (h *DashboardHandler) GetRecentActivity(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        activities := []*models.ActivityItem{}

        // Get recent bookings (last 24 hours)
        yesterday := time.Now().Add(-24 * time.Hour).Format("2006-01-02")
        recentBookings, err := h.bookingRepo.FindAll(&amp;models.BookingFilterRequest{
                DateFrom: &amp;yesterday,
        })

        if err == nil </span><span class="cov1" title="1">{
                for _, booking := range recentBookings </span><span class="cov1" title="1">{
                        // Get dog name
                        dog, err := h.dogRepo.FindByID(booking.DogID)
                        dogName := "Unknown"
                        if err == nil &amp;&amp; dog != nil </span><span class="cov1" title="1">{
                                dogName = dog.Name
                        }</span>

                        <span class="cov1" title="1">var activityType, message string
                        switch booking.Status </span>{
                        case "scheduled":<span class="cov1" title="1">
                                activityType = "booking_created"
                                message = "Neue Buchung fr " + dogName</span>
                        case "completed":<span class="cov0" title="0">
                                activityType = "booking_completed"
                                message = "Spaziergang mit " + dogName + " abgeschlossen"</span>
                        case "cancelled":<span class="cov0" title="0">
                                activityType = "booking_cancelled"
                                message = "Buchung fr " + dogName + " storniert"</span>
                        }

                        <span class="cov1" title="1">activity := &amp;models.ActivityItem{
                                Type:      activityType,
                                Message:   message,
                                Timestamp: booking.CreatedAt.Format(time.RFC3339),
                                UserID:    &amp;booking.UserID,
                                DogID:     &amp;booking.DogID,
                                DogName:   dogName,
                        }

                        activities = append(activities, activity)</span>
                }
        }

        // Limit to 20 most recent activities
        <span class="cov1" title="1">if len(activities) &gt; 20 </span><span class="cov0" title="0">{
                activities = activities[:20]
        }</span>

        <span class="cov1" title="1">response := &amp;models.RecentActivityResponse{
                Activities: activities,
        }

        respondJSON(w, http.StatusOK, response)</span>
}

// Helper functions
func strPtr(s string) *string <span class="cov5" title="2">{
        return &amp;s
}</span>

func boolPtr(b bool) *bool <span class="cov10" title="4">{
        return &amp;b
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/middleware"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
)

// DogHandler handles dog-related endpoints
type DogHandler struct {
        dogRepo  *repository.DogRepository
        userRepo *repository.UserRepository
        config   *config.Config
}

// NewDogHandler creates a new dog handler
func NewDogHandler(db *sql.DB, cfg *config.Config) *DogHandler <span class="cov10" title="7">{
        return &amp;DogHandler{
                dogRepo:  repository.NewDogRepository(db),
                userRepo: repository.NewUserRepository(db),
                config:   cfg,
        }
}</span>

// ListDogs handles GET /api/dogs - list all dogs with optional filters
func (h *DogHandler) ListDogs(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        // Parse query parameters for filtering
        filter := &amp;models.DogFilterRequest{}

        if breed := r.URL.Query().Get("breed"); breed != "" </span><span class="cov0" title="0">{
                filter.Breed = &amp;breed
        }</span>

        <span class="cov6" title="3">if size := r.URL.Query().Get("size"); size != "" </span><span class="cov0" title="0">{
                filter.Size = &amp;size
        }</span>

        <span class="cov6" title="3">if minAge := r.URL.Query().Get("min_age"); minAge != "" </span><span class="cov0" title="0">{
                if age, err := strconv.Atoi(minAge); err == nil </span><span class="cov0" title="0">{
                        filter.MinAge = &amp;age
                }</span>
        }

        <span class="cov6" title="3">if maxAge := r.URL.Query().Get("max_age"); maxAge != "" </span><span class="cov0" title="0">{
                if age, err := strconv.Atoi(maxAge); err == nil </span><span class="cov0" title="0">{
                        filter.MaxAge = &amp;age
                }</span>
        }

        <span class="cov6" title="3">if category := r.URL.Query().Get("category"); category != "" </span><span class="cov1" title="1">{
                filter.Category = &amp;category
        }</span>

        <span class="cov6" title="3">if available := r.URL.Query().Get("available"); available != "" </span><span class="cov1" title="1">{
                avail := available == "true" || available == "1"
                filter.Available = &amp;avail
        }</span>

        <span class="cov6" title="3">if search := r.URL.Query().Get("search"); search != "" </span><span class="cov0" title="0">{
                filter.Search = &amp;search
        }</span>

        // Get dogs
        <span class="cov6" title="3">dogs, err := h.dogRepo.FindAll(filter)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to fetch dogs")
                return
        }</span>

        // If user is authenticated, filter based on their experience level
        <span class="cov6" title="3">userID, ok := r.Context().Value(middleware.UserIDKey).(int)
        if ok </span><span class="cov6" title="3">{
                user, err := h.userRepo.FindByID(userID)
                if err == nil &amp;&amp; user != nil </span><span class="cov6" title="3">{
                        filteredDogs := []*models.Dog{}
                        for _, dog := range dogs </span><span class="cov10" title="7">{
                                // Check if user can access this dog
                                if repository.CanUserAccessDog(user.ExperienceLevel, dog.Category) </span><span class="cov6" title="3">{
                                        filteredDogs = append(filteredDogs, dog)
                                }</span> else<span class="cov7" title="4"> {
                                        // Include but mark as inaccessible (frontend will handle display)
                                        filteredDogs = append(filteredDogs, dog)
                                }</span>
                        }
                        <span class="cov6" title="3">dogs = filteredDogs</span>
                }
        }

        <span class="cov6" title="3">respondJSON(w, http.StatusOK, dogs)</span>
}

// GetDog handles GET /api/dogs/:id - get a single dog
func (h *DogHandler) GetDog(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Invalid dog ID")
                return
        }</span>

        <span class="cov4" title="2">dog, err := h.dogRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>

        <span class="cov4" title="2">if dog == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "Dog not found")
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, dog)</span>
}

// CreateDog handles POST /api/dogs - create a new dog (admin only)
func (h *DogHandler) CreateDog(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        var req models.CreateDogRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate required fields
        <span class="cov7" title="4">if strings.TrimSpace(req.Name) == "" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Name is required")
                return
        }</span>

        <span class="cov6" title="3">if strings.TrimSpace(req.Breed) == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Breed is required")
                return
        }</span>

        <span class="cov6" title="3">if req.Size != "small" &amp;&amp; req.Size != "medium" &amp;&amp; req.Size != "large" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Size must be small, medium, or large")
                return
        }</span>

        <span class="cov6" title="3">if req.Category != "green" &amp;&amp; req.Category != "blue" &amp;&amp; req.Category != "orange" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "Category must be green, blue, or orange")
                return
        }</span>

        // Create dog
        <span class="cov4" title="2">dog := &amp;models.Dog{
                Name:                req.Name,
                Breed:               req.Breed,
                Size:                req.Size,
                Age:                 req.Age,
                Category:            req.Category,
                SpecialNeeds:        req.SpecialNeeds,
                PickupLocation:      req.PickupLocation,
                WalkRoute:           req.WalkRoute,
                WalkDuration:        req.WalkDuration,
                SpecialInstructions: req.SpecialInstructions,
                DefaultMorningTime:  req.DefaultMorningTime,
                DefaultEveningTime:  req.DefaultEveningTime,
                IsAvailable:         true, // Default to available
        }

        if err := h.dogRepo.Create(dog); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create dog")
                return
        }</span>

        <span class="cov4" title="2">respondJSON(w, http.StatusCreated, dog)</span>
}

// UpdateDog handles PUT /api/dogs/:id - update a dog (admin only)
func (h *DogHandler) UpdateDog(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid dog ID")
                return
        }</span>

        // Get existing dog
        <span class="cov4" title="2">dog, err := h.dogRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>

        <span class="cov4" title="2">if dog == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "Dog not found")
                return
        }</span>

        // Parse update request
        <span class="cov1" title="1">var req models.UpdateDogRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Update fields if provided
        <span class="cov1" title="1">if req.Name != nil </span><span class="cov1" title="1">{
                dog.Name = *req.Name
        }</span>
        <span class="cov1" title="1">if req.Breed != nil </span><span class="cov0" title="0">{
                dog.Breed = *req.Breed
        }</span>
        <span class="cov1" title="1">if req.Size != nil </span><span class="cov0" title="0">{
                dog.Size = *req.Size
        }</span>
        <span class="cov1" title="1">if req.Age != nil </span><span class="cov1" title="1">{
                dog.Age = *req.Age
        }</span>
        <span class="cov1" title="1">if req.Category != nil </span><span class="cov0" title="0">{
                dog.Category = *req.Category
        }</span>
        <span class="cov1" title="1">if req.SpecialNeeds != nil </span><span class="cov0" title="0">{
                dog.SpecialNeeds = req.SpecialNeeds
        }</span>
        <span class="cov1" title="1">if req.PickupLocation != nil </span><span class="cov0" title="0">{
                dog.PickupLocation = req.PickupLocation
        }</span>
        <span class="cov1" title="1">if req.WalkRoute != nil </span><span class="cov0" title="0">{
                dog.WalkRoute = req.WalkRoute
        }</span>
        <span class="cov1" title="1">if req.WalkDuration != nil </span><span class="cov0" title="0">{
                dog.WalkDuration = req.WalkDuration
        }</span>
        <span class="cov1" title="1">if req.SpecialInstructions != nil </span><span class="cov0" title="0">{
                dog.SpecialInstructions = req.SpecialInstructions
        }</span>
        <span class="cov1" title="1">if req.DefaultMorningTime != nil </span><span class="cov0" title="0">{
                dog.DefaultMorningTime = req.DefaultMorningTime
        }</span>
        <span class="cov1" title="1">if req.DefaultEveningTime != nil </span><span class="cov0" title="0">{
                dog.DefaultEveningTime = req.DefaultEveningTime
        }</span>

        // Update in database
        <span class="cov1" title="1">if err := h.dogRepo.Update(dog); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update dog")
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, dog)</span>
}

// DeleteDog handles DELETE /api/dogs/:id - delete a dog (admin only)
func (h *DogHandler) DeleteDog(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid dog ID")
                return
        }</span>

        // Delete (will fail if future bookings exist)
        <span class="cov4" title="2">if err := h.dogRepo.Delete(id); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "future bookings") </span><span class="cov0" title="0">{
                        respondError(w, http.StatusConflict, "Cannot delete dog with future bookings")
                }</span> else<span class="cov0" title="0"> {
                        respondError(w, http.StatusInternalServerError, "Failed to delete dog")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov4" title="2">respondJSON(w, http.StatusOK, map[string]string{
                "message": "Dog deleted successfully",
        })</span>
}

// UploadDogPhoto handles POST /api/dogs/:id/photo - upload dog photo (admin only)
func (h *DogHandler) UploadDogPhoto(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid dog ID")
                return
        }</span>

        // Get existing dog
        <span class="cov0" title="0">dog, err := h.dogRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>

        <span class="cov0" title="0">if dog == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Dog not found")
                return
        }</span>

        // Parse multipart form
        <span class="cov0" title="0">if err := r.ParseMultipartForm(int64(h.config.MaxUploadSizeMB) &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "File too large or invalid form")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("photo")
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "No file uploaded")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Validate file type
        ext := strings.ToLower(filepath.Ext(header.Filename))
        if ext != ".jpg" &amp;&amp; ext != ".jpeg" &amp;&amp; ext != ".png" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Only JPEG and PNG files are allowed")
                return
        }</span>

        // Create upload directory if it doesn't exist
        <span class="cov0" title="0">dogDir := filepath.Join(h.config.UploadDir, "dogs")
        if err := os.MkdirAll(dogDir, 0755); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create upload directory")
                return
        }</span>

        // Generate filename
        <span class="cov0" title="0">filename := fmt.Sprintf("dog_%d%s", id, ext)
        relPath := filepath.Join("dogs", filename)
        destPath := filepath.Join(h.config.UploadDir, relPath)

        // Save file
        dest, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to save file")
                return
        }</span>
        <span class="cov0" title="0">defer dest.Close()

        if _, err := io.Copy(dest, file); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to save file")
                return
        }</span>

        // Delete old photo if exists
        <span class="cov0" title="0">if dog.Photo != nil &amp;&amp; *dog.Photo != "" </span><span class="cov0" title="0">{
                oldPath := filepath.Join(h.config.UploadDir, *dog.Photo)
                os.Remove(oldPath) // Ignore errors
        }</span>

        // Update dog
        <span class="cov0" title="0">dog.Photo = &amp;relPath
        if err := h.dogRepo.Update(dog); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update dog")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{
                "message": "Photo uploaded successfully",
                "photo":   relPath,
        })</span>
}

// ToggleAvailability handles PUT /api/dogs/:id/availability - toggle availability (admin only)
func (h *DogHandler) ToggleAvailability(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid dog ID")
                return
        }</span>

        <span class="cov4" title="2">var req models.ToggleAvailabilityRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // If marking as unavailable, reason is optional but recommended
        <span class="cov4" title="2">if !req.IsAvailable &amp;&amp; (req.UnavailableReason == nil || *req.UnavailableReason == "") </span><span class="cov0" title="0">{
                defaultReason := "Temporarily unavailable"
                req.UnavailableReason = &amp;defaultReason
        }</span>

        // Toggle availability
        <span class="cov4" title="2">if err := h.dogRepo.ToggleAvailability(id, req.IsAvailable, req.UnavailableReason); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to toggle availability")
                return
        }</span>

        // Get updated dog
        <span class="cov4" title="2">dog, err := h.dogRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to fetch updated dog")
                return
        }</span>

        <span class="cov4" title="2">respondJSON(w, http.StatusOK, dog)</span>
}

// GetBreeds handles GET /api/dogs/breeds - get list of all breeds
func (h *DogHandler) GetBreeds(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        breeds, err := h.dogRepo.GetBreeds()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to fetch breeds")
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, breeds)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
        "github.com/tranm/gassigeher/internal/services"
)

// ExperienceRequestHandler handles experience request-related HTTP requests
type ExperienceRequestHandler struct {
        db         *sql.DB
        cfg        *config.Config
        requestRepo *repository.ExperienceRequestRepository
        userRepo    *repository.UserRepository
        emailService *services.EmailService
}

// NewExperienceRequestHandler creates a new experience request handler
func NewExperienceRequestHandler(db *sql.DB, cfg *config.Config) *ExperienceRequestHandler <span class="cov8" title="4">{
        emailService, err := services.NewEmailService(
                cfg.GmailClientID,
                cfg.GmailClientSecret,
                cfg.GmailRefreshToken,
                cfg.GmailFromEmail,
        )
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail
                println("Warning: Failed to initialize email service:", err.Error())
        }</span>

        <span class="cov8" title="4">return &amp;ExperienceRequestHandler{
                db:           db,
                cfg:          cfg,
                requestRepo:  repository.NewExperienceRequestRepository(db),
                userRepo:     repository.NewUserRepository(db),
                emailService: emailService,
        }</span>
}

// CreateRequest creates a new experience level request
func (h *ExperienceRequestHandler) CreateRequest(w http.ResponseWriter, r *http.Request) <span class="cov10" title="5">{
        // Get user ID from context
        userID, ok := r.Context().Value("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Parse request
        <span class="cov10" title="5">var req models.CreateExperienceRequestRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate request
        <span class="cov10" title="5">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get user
        <span class="cov8" title="4">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get user")
                return
        }</span>
        <span class="cov8" title="4">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Check if user already has this level or higher
        <span class="cov8" title="4">currentLevel := user.ExperienceLevel
        requestedLevel := req.RequestedLevel

        if currentLevel == "orange" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "You already have the highest level")
                return
        }</span>

        <span class="cov8" title="4">if currentLevel == "blue" &amp;&amp; requestedLevel == "blue" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "You already have this level")
                return
        }</span>

        <span class="cov8" title="4">if currentLevel == "green" &amp;&amp; requestedLevel == "orange" </span><span class="cov1" title="1">{
                respondError(w, http.StatusBadRequest, "You must first get blue level")
                return
        }</span>

        // Check if user already has a pending request for this level
        <span class="cov7" title="3">hasPending, err := h.requestRepo.HasPendingRequest(userID, requestedLevel)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to check pending requests")
                return
        }</span>
        <span class="cov7" title="3">if hasPending </span><span class="cov1" title="1">{
                respondError(w, http.StatusConflict, "You already have a pending request for this level")
                return
        }</span>

        // Create request
        <span class="cov4" title="2">experienceRequest := &amp;models.ExperienceRequest{
                UserID:         userID,
                RequestedLevel: requestedLevel,
        }

        if err := h.requestRepo.Create(experienceRequest); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create request")
                return
        }</span>

        <span class="cov4" title="2">respondJSON(w, http.StatusCreated, experienceRequest)</span>
}

// ListRequests lists experience requests (user sees own, admin sees all pending)
func (h *ExperienceRequestHandler) ListRequests(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        // Get user ID and admin status from context
        userID, _ := r.Context().Value("user_id").(int)
        isAdmin, _ := r.Context().Value("is_admin").(bool)

        var requests []*models.ExperienceRequest
        var err error

        if isAdmin </span><span class="cov1" title="1">{
                // Admin sees all pending requests
                requests, err = h.requestRepo.FindAllPending()
        }</span> else<span class="cov1" title="1"> {
                // User sees their own requests
                requests, err = h.requestRepo.FindByUserID(userID)
        }</span>

        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get requests")
                return
        }</span>

        // If admin, populate user details
        <span class="cov4" title="2">if isAdmin </span><span class="cov1" title="1">{
                for _, req := range requests </span><span class="cov4" title="2">{
                        user, err := h.userRepo.FindByID(req.UserID)
                        if err == nil &amp;&amp; user != nil </span><span class="cov4" title="2">{
                                req.User = user
                        }</span>
                }
        }

        <span class="cov4" title="2">respondJSON(w, http.StatusOK, requests)</span>
}

// ApproveRequest approves an experience request (admin only)
func (h *ExperienceRequestHandler) ApproveRequest(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        // Get request ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request ID")
                return
        }</span>

        // Get admin user ID
        <span class="cov4" title="2">reviewerID, _ := r.Context().Value("user_id").(int)

        // Parse request body
        var req models.ReviewExperienceRequestRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Allow empty body
                req = models.ReviewExperienceRequestRequest{}
        }</span>

        // Get experience request
        <span class="cov4" title="2">experienceRequest, err := h.requestRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get request")
                return
        }</span>
        <span class="cov4" title="2">if experienceRequest == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "Request not found")
                return
        }</span>

        // Check if already reviewed
        <span class="cov1" title="1">if experienceRequest.Status != "pending" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Request has already been reviewed")
                return
        }</span>

        // Get user
        <span class="cov1" title="1">user, err := h.userRepo.FindByID(experienceRequest.UserID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get user")
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Approve request
        <span class="cov1" title="1">if err := h.requestRepo.Approve(id, reviewerID, req.Message); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to approve request")
                return
        }</span>

        // Update user experience level
        <span class="cov1" title="1">user.ExperienceLevel = experienceRequest.RequestedLevel
        if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update user level")
                return
        }</span>

        // Send email notification
        <span class="cov1" title="1">if user.Email != nil </span><span class="cov1" title="1">{
                go h.emailService.SendExperienceLevelApproved(*user.Email, user.Name, experienceRequest.RequestedLevel, req.Message)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Request approved"})</span>
}

// DenyRequest denies an experience request (admin only)
func (h *ExperienceRequestHandler) DenyRequest(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        // Get request ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request ID")
                return
        }</span>

        // Get admin user ID
        <span class="cov1" title="1">reviewerID, _ := r.Context().Value("user_id").(int)

        // Parse request body
        var req models.ReviewExperienceRequestRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Allow empty body
                req = models.ReviewExperienceRequestRequest{}
        }</span>

        // Get experience request
        <span class="cov1" title="1">experienceRequest, err := h.requestRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get request")
                return
        }</span>
        <span class="cov1" title="1">if experienceRequest == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Request not found")
                return
        }</span>

        // Check if already reviewed
        <span class="cov1" title="1">if experienceRequest.Status != "pending" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Request has already been reviewed")
                return
        }</span>

        // Get user
        <span class="cov1" title="1">user, err := h.userRepo.FindByID(experienceRequest.UserID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get user")
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Deny request
        <span class="cov1" title="1">if err := h.requestRepo.Deny(id, reviewerID, req.Message); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to deny request")
                return
        }</span>

        // Send email notification
        <span class="cov1" title="1">if user.Email != nil </span><span class="cov1" title="1">{
                go h.emailService.SendExperienceLevelDenied(*user.Email, user.Name, experienceRequest.RequestedLevel, req.Message)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Request denied"})</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
        "github.com/tranm/gassigeher/internal/services"
)

// ReactivationRequestHandler handles reactivation request-related HTTP requests
type ReactivationRequestHandler struct {
        db          *sql.DB
        cfg         *config.Config
        requestRepo *repository.ReactivationRequestRepository
        userRepo    *repository.UserRepository
        emailService *services.EmailService
}

// NewReactivationRequestHandler creates a new reactivation request handler
func NewReactivationRequestHandler(db *sql.DB, cfg *config.Config) *ReactivationRequestHandler <span class="cov10" title="4">{
        emailService, err := services.NewEmailService(
                cfg.GmailClientID,
                cfg.GmailClientSecret,
                cfg.GmailRefreshToken,
                cfg.GmailFromEmail,
        )
        if err != nil </span><span class="cov0" title="0">{
                println("Warning: Failed to initialize email service:", err.Error())
        }</span>

        <span class="cov10" title="4">return &amp;ReactivationRequestHandler{
                db:           db,
                cfg:          cfg,
                requestRepo:  repository.NewReactivationRequestRepository(db),
                userRepo:     repository.NewUserRepository(db),
                emailService: emailService,
        }</span>
}

// CreateRequest creates a new reactivation request (for deactivated users)
func (h *ReactivationRequestHandler) CreateRequest(w http.ResponseWriter, r *http.Request) <span class="cov10" title="4">{
        // Parse request to get user email (since they can't be authenticated)
        var req struct {
                Email string `json:"email"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov10" title="4">if req.Email == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Email is required")
                return
        }</span>

        // Find user by email
        <span class="cov10" title="4">user, err := h.userRepo.FindByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov10" title="4">if user == nil </span><span class="cov0" title="0">{
                // Don't reveal if user exists or not for security
                respondJSON(w, http.StatusOK, map[string]string{"message": "If your account exists and is deactivated, a request has been sent"})
                return
        }</span>

        // Check if user is actually deactivated
        <span class="cov10" title="4">if user.IsActive </span><span class="cov1" title="1">{
                respondJSON(w, http.StatusOK, map[string]string{"message": "Your account is already active"})
                return
        }</span>

        // Check if user already has a pending request
        <span class="cov8" title="3">hasPending, err := h.requestRepo.HasPendingRequest(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to check pending requests")
                return
        }</span>
        <span class="cov8" title="3">if hasPending </span><span class="cov1" title="1">{
                respondJSON(w, http.StatusOK, map[string]string{"message": "You already have a pending request"})
                return
        }</span>

        // Create request
        <span class="cov5" title="2">reactivationRequest := &amp;models.ReactivationRequest{
                UserID: user.ID,
        }

        if err := h.requestRepo.Create(reactivationRequest); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create request")
                return
        }</span>

        <span class="cov5" title="2">respondJSON(w, http.StatusCreated, map[string]string{"message": "Reactivation request submitted"})</span>
}

// ListRequests lists reactivation requests (admin sees all pending)
func (h *ReactivationRequestHandler) ListRequests(w http.ResponseWriter, r *http.Request) <span class="cov5" title="2">{
        requests, err := h.requestRepo.FindAllPending()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get requests")
                return
        }</span>

        // Populate user details
        <span class="cov5" title="2">for _, req := range requests </span><span class="cov10" title="4">{
                user, err := h.userRepo.FindByID(req.UserID)
                if err == nil &amp;&amp; user != nil </span><span class="cov10" title="4">{
                        req.User = user
                }</span>
        }

        <span class="cov5" title="2">respondJSON(w, http.StatusOK, requests)</span>
}

// ApproveRequest approves a reactivation request (admin only)
func (h *ReactivationRequestHandler) ApproveRequest(w http.ResponseWriter, r *http.Request) <span class="cov5" title="2">{
        // Get request ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request ID")
                return
        }</span>

        // Get admin user ID
        <span class="cov5" title="2">reviewerID, _ := r.Context().Value("user_id").(int)

        // Parse request body
        var req models.ReviewReactivationRequestRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Allow empty body
                req = models.ReviewReactivationRequestRequest{}
        }</span>

        // Get reactivation request
        <span class="cov5" title="2">reactivationRequest, err := h.requestRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get request")
                return
        }</span>
        <span class="cov5" title="2">if reactivationRequest == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "Request not found")
                return
        }</span>

        // Check if already reviewed
        <span class="cov1" title="1">if reactivationRequest.Status != "pending" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Request has already been reviewed")
                return
        }</span>

        // Get user
        <span class="cov1" title="1">user, err := h.userRepo.FindByID(reactivationRequest.UserID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get user")
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Approve request
        <span class="cov1" title="1">if err := h.requestRepo.Approve(id, reviewerID, req.Message); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to approve request")
                return
        }</span>

        // Activate user
        <span class="cov1" title="1">if err := h.userRepo.Activate(reactivationRequest.UserID); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to activate user")
                return
        }</span>

        // Send email notification
        <span class="cov1" title="1">if user.Email != nil </span><span class="cov1" title="1">{
                go h.emailService.SendAccountReactivated(*user.Email, user.Name, req.Message)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Request approved and user reactivated"})</span>
}

// DenyRequest denies a reactivation request (admin only)
func (h *ReactivationRequestHandler) DenyRequest(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        // Get request ID from URL
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request ID")
                return
        }</span>

        // Get admin user ID
        <span class="cov1" title="1">reviewerID, _ := r.Context().Value("user_id").(int)

        // Parse request body
        var req models.ReviewReactivationRequestRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Allow empty body
                req = models.ReviewReactivationRequestRequest{}
        }</span>

        // Get reactivation request
        <span class="cov1" title="1">reactivationRequest, err := h.requestRepo.FindByID(id)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get request")
                return
        }</span>
        <span class="cov1" title="1">if reactivationRequest == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "Request not found")
                return
        }</span>

        // Check if already reviewed
        <span class="cov1" title="1">if reactivationRequest.Status != "pending" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Request has already been reviewed")
                return
        }</span>

        // Get user
        <span class="cov1" title="1">user, err := h.userRepo.FindByID(reactivationRequest.UserID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get user")
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Deny request
        <span class="cov1" title="1">if err := h.requestRepo.Deny(id, reviewerID, req.Message); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to deny request")
                return
        }</span>

        // Send email notification
        <span class="cov1" title="1">if user.Email != nil </span><span class="cov1" title="1">{
                go h.emailService.SendReactivationDenied(*user.Email, user.Name, req.Message)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Request denied"})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
)

// SettingsHandler handles system settings-related HTTP requests
type SettingsHandler struct {
        db           *sql.DB
        cfg          *config.Config
        settingsRepo *repository.SettingsRepository
}

// NewSettingsHandler creates a new settings handler
func NewSettingsHandler(db *sql.DB, cfg *config.Config) *SettingsHandler <span class="cov6" title="2">{
        return &amp;SettingsHandler{
                db:           db,
                cfg:          cfg,
                settingsRepo: repository.NewSettingsRepository(db),
        }
}</span>

// GetAllSettings gets all system settings (admin only)
func (h *SettingsHandler) GetAllSettings(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        settings, err := h.settingsRepo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get settings")
                return
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, settings)</span>
}

// UpdateSetting updates a system setting (admin only)
func (h *SettingsHandler) UpdateSetting(w http.ResponseWriter, r *http.Request) <span class="cov10" title="3">{
        // Get key from URL
        vars := mux.Vars(r)
        key := vars["key"]

        // Parse request
        var req models.UpdateSettingRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Validate request
        <span class="cov10" title="3">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Update setting
        <span class="cov10" title="3">if err := h.settingsRepo.Update(key, req.Value); err != nil </span><span class="cov1" title="1">{
                if err.Error() == "setting not found" </span><span class="cov1" title="1">{
                        respondError(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">respondError(w, http.StatusInternalServerError, "Failed to update setting")
                return</span>
        }

        <span class="cov6" title="2">respondJSON(w, http.StatusOK, map[string]string{"message": "Setting updated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/tranm/gassigeher/internal/config"
        "github.com/tranm/gassigeher/internal/middleware"
        "github.com/tranm/gassigeher/internal/models"
        "github.com/tranm/gassigeher/internal/repository"
        "github.com/tranm/gassigeher/internal/services"
)

// UserHandler handles user-related endpoints
type UserHandler struct {
        userRepo     *repository.UserRepository
        authService  *services.AuthService
        emailService *services.EmailService
        config       *config.Config
}

// NewUserHandler creates a new user handler
func NewUserHandler(db *sql.DB, cfg *config.Config) *UserHandler <span class="cov8" title="3">{
        emailService, err := services.NewEmailService(
                cfg.GmailClientID,
                cfg.GmailClientSecret,
                cfg.GmailRefreshToken,
                cfg.GmailFromEmail,
        )
        if err != nil </span><span class="cov0" title="0">{
                println("Warning: Failed to initialize email service:", err.Error())
        }</span>

        <span class="cov8" title="3">return &amp;UserHandler{
                userRepo:     repository.NewUserRepository(db),
                authService:  services.NewAuthService(cfg.JWTSecret, cfg.JWTExpirationHours),
                emailService: emailService,
                config:       cfg,
        }</span>
}

// GetMe returns the current user's profile
func (h *UserHandler) GetMe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="3">{
        userID, ok := r.Context().Value(middleware.UserIDKey).(int)
        if !ok </span><span class="cov1" title="1">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov5" title="2">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov5" title="2">if user == nil </span><span class="cov1" title="1">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Don't return sensitive data
        <span class="cov1" title="1">user.PasswordHash = nil
        user.VerificationToken = nil
        user.PasswordResetToken = nil

        respondJSON(w, http.StatusOK, user)</span>
}

// UpdateMe updates the current user's profile
func (h *UserHandler) UpdateMe(w http.ResponseWriter, r *http.Request) <span class="cov10" title="4">{
        userID, ok := r.Context().Value(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov10" title="4">var req models.UpdateProfileRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov10" title="4">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov10" title="4">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Track if email changed
        <span class="cov10" title="4">emailChanged := false

        // Update fields
        if req.Name != nil &amp;&amp; strings.TrimSpace(*req.Name) != "" </span><span class="cov1" title="1">{
                user.Name = *req.Name
        }</span>

        <span class="cov10" title="4">if req.Phone != nil &amp;&amp; strings.TrimSpace(*req.Phone) != "" </span><span class="cov1" title="1">{
                user.Phone = req.Phone
        }</span>

        // Handle email change - requires re-verification
        <span class="cov10" title="4">if req.Email != nil &amp;&amp; strings.TrimSpace(*req.Email) != "" </span><span class="cov5" title="2">{
                newEmail := strings.TrimSpace(*req.Email)

                // Check if email actually changed
                if user.Email != nil &amp;&amp; *user.Email != newEmail </span><span class="cov5" title="2">{
                        // Check if new email already exists
                        existingUser, err := h.userRepo.FindByEmail(newEmail)
                        if err != nil </span><span class="cov0" title="0">{
                                respondError(w, http.StatusInternalServerError, "Database error")
                                return
                        }</span>
                        <span class="cov5" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                                respondError(w, http.StatusConflict, "Email already in use")
                                return
                        }</span>

                        // Generate new verification token
                        <span class="cov1" title="1">token, err := h.authService.GenerateToken()
                        if err != nil </span><span class="cov0" title="0">{
                                respondError(w, http.StatusInternalServerError, "Failed to generate token")
                                return
                        }</span>

                        <span class="cov1" title="1">user.Email = &amp;newEmail
                        user.VerificationToken = &amp;token
                        user.IsVerified = false
                        emailChanged = true

                        // Set token expiration
                        expires := time.Now().Add(24 * time.Hour)
                        user.VerificationTokenExpires = &amp;expires</span>
                }
        }

        <span class="cov8" title="3">if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update profile")
                return
        }</span>

        // Send verification email if email changed
        <span class="cov8" title="3">if emailChanged &amp;&amp; user.Email != nil </span><span class="cov1" title="1">{
                go h.emailService.SendVerificationEmail(*user.Email, user.Name, *user.VerificationToken)
        }</span>

        // Don't return sensitive data
        <span class="cov8" title="3">user.PasswordHash = nil
        user.VerificationToken = nil
        user.PasswordResetToken = nil

        message := "Profile updated successfully"
        if emailChanged </span><span class="cov1" title="1">{
                message = "Profile updated. Please check your new email to verify it."
        }</span>

        <span class="cov8" title="3">respondJSON(w, http.StatusOK, map[string]interface{}{
                "message": message,
                "user":    user,
        })</span>
}

// UploadPhoto handles profile photo upload
func (h *UserHandler) UploadPhoto(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID, ok := r.Context().Value(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Parse multipart form
        <span class="cov0" title="0">if err := r.ParseMultipartForm(int64(h.config.MaxUploadSizeMB) &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "File too large or invalid form")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("photo")
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "No file uploaded")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Validate file type
        ext := strings.ToLower(filepath.Ext(header.Filename))
        if ext != ".jpg" &amp;&amp; ext != ".jpeg" &amp;&amp; ext != ".png" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Only JPEG and PNG files are allowed")
                return
        }</span>

        // Create upload directory if it doesn't exist
        <span class="cov0" title="0">userDir := filepath.Join(h.config.UploadDir, "users")
        if err := os.MkdirAll(userDir, 0755); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to create upload directory")
                return
        }</span>

        // Generate filename
        <span class="cov0" title="0">filename := filepath.Join("users", filepath.Base(header.Filename))
        destPath := filepath.Join(h.config.UploadDir, filename)

        // Save file
        dest, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to save file")
                return
        }</span>
        <span class="cov0" title="0">defer dest.Close()

        if _, err := io.Copy(dest, file); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to save file")
                return
        }</span>

        // Update user profile
        <span class="cov0" title="0">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Delete old photo if exists
        <span class="cov0" title="0">if user.ProfilePhoto != nil &amp;&amp; *user.ProfilePhoto != "" </span><span class="cov0" title="0">{
                oldPath := filepath.Join(h.config.UploadDir, *user.ProfilePhoto)
                os.Remove(oldPath) // Ignore errors
        }</span>

        <span class="cov0" title="0">user.ProfilePhoto = &amp;filename
        if err := h.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to update profile")
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{
                "message": "Photo uploaded successfully",
                "photo":   filename,
        })</span>
}

// DeleteAccount deletes the current user's account (GDPR anonymization)
func (h *UserHandler) DeleteAccount(w http.ResponseWriter, r *http.Request) <span class="cov5" title="2">{
        userID, ok := r.Context().Value(middleware.UserIDKey).(int)
        if !ok </span><span class="cov1" title="1">{
                respondError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Parse request to get password confirmation
        <span class="cov1" title="1">var req struct {
                Password string `json:"password"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov1" title="1">if req.Password == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Password is required to confirm deletion")
                return
        }</span>

        // Get user
        <span class="cov1" title="1">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Verify password
        <span class="cov1" title="1">if user.PasswordHash == nil || !h.authService.CheckPassword(req.Password, *user.PasswordHash) </span><span class="cov0" title="0">{
                respondError(w, http.StatusUnauthorized, "Invalid password")
                return
        }</span>

        // Store email for confirmation before deletion
        <span class="cov1" title="1">var emailForConfirmation string
        if user.Email != nil </span><span class="cov1" title="1">{
                emailForConfirmation = *user.Email
        }</span>

        // Delete account (GDPR anonymization)
        <span class="cov1" title="1">if err := h.userRepo.DeleteAccount(userID); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to delete account")
                return
        }</span>

        // Send confirmation email to original email
        <span class="cov1" title="1">if emailForConfirmation != "" </span><span class="cov1" title="1">{
                go h.emailService.SendAccountDeletionConfirmation(emailForConfirmation, user.Name)
        }</span>

        <span class="cov1" title="1">respondJSON(w, http.StatusOK, map[string]string{"message": "Account deleted successfully"})</span>
}

// ListUsers lists all users (admin only)
func (h *UserHandler) ListUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse filters
        var activeOnly *bool
        if activeParam := r.URL.Query().Get("active"); activeParam != "" </span><span class="cov0" title="0">{
                active := activeParam == "true" || activeParam == "1"
                activeOnly = &amp;active
        }</span>

        <span class="cov0" title="0">users, err := h.userRepo.FindAll(activeOnly)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to get users")
                return
        }</span>

        // Don't return sensitive data
        <span class="cov0" title="0">for _, user := range users </span><span class="cov0" title="0">{
                user.PasswordHash = nil
                user.VerificationToken = nil
                user.PasswordResetToken = nil
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, users)</span>
}

// GetUser gets a user by ID (admin only)
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user ID from URL
        vars := mux.Vars(r)
        userID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid user ID")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Don't return sensitive data
        <span class="cov0" title="0">user.PasswordHash = nil
        user.VerificationToken = nil
        user.PasswordResetToken = nil

        respondJSON(w, http.StatusOK, user)</span>
}

// DeactivateUser deactivates a user account (admin only)
func (h *UserHandler) DeactivateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user ID from URL
        vars := mux.Vars(r)
        userID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid user ID")
                return
        }</span>

        // Parse request
        <span class="cov0" title="0">var req struct {
                Reason string `json:"reason"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if req.Reason == "" </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Reason is required")
                return
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Deactivate
        <span class="cov0" title="0">if err := h.userRepo.Deactivate(userID, req.Reason); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to deactivate user")
                return
        }</span>

        // Send email notification
        <span class="cov0" title="0">if user.Email != nil </span><span class="cov0" title="0">{
                go h.emailService.SendAccountDeactivated(*user.Email, user.Name, req.Reason)
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "User deactivated successfully"})</span>
}

// ActivateUser activates a user account (admin only)
func (h *UserHandler) ActivateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user ID from URL
        vars := mux.Vars(r)
        userID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusBadRequest, "Invalid user ID")
                return
        }</span>

        // Parse optional message
        <span class="cov0" title="0">var req struct {
                Message *string `json:"message,omitempty"`
        }
        json.NewDecoder(r.Body).Decode(&amp;req)

        // Get user
        user, err := h.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Database error")
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusNotFound, "User not found")
                return
        }</span>

        // Activate
        <span class="cov0" title="0">if err := h.userRepo.Activate(userID); err != nil </span><span class="cov0" title="0">{
                respondError(w, http.StatusInternalServerError, "Failed to activate user")
                return
        }</span>

        // Send email notification
        <span class="cov0" title="0">if user.Email != nil </span><span class="cov0" title="0">{
                go h.emailService.SendAccountReactivated(*user.Email, user.Name, req.Message)
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "User activated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "github.com/tranm/gassigeher/internal/services"
)

type contextKey string

const UserIDKey contextKey = "userID"
const EmailKey contextKey = "email"
const IsAdminKey contextKey = "isAdmin"

// LoggingMiddleware logs HTTP requests
func LoggingMiddleware(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                start := time.Now()
                log.Printf("%s %s", r.Method, r.URL.Path)
                next.ServeHTTP(w, r)
                log.Printf("Completed in %v", time.Since(start))
        }</span>)
}

// CORSMiddleware adds CORS headers
func CORSMiddleware(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov1" title="1">next.ServeHTTP(w, r)</span>
        })
}

// AuthMiddleware validates JWT tokens
func AuthMiddleware(jwtSecret string) func(http.Handler) http.Handler <span class="cov1" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="6">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="6">{
                        authHeader := r.Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov1" title="1">{
                                http.Error(w, `{"error":"Missing authorization header"}`, http.StatusUnauthorized)
                                return
                        }</span>

                        // Extract token from "Bearer &lt;token&gt;"
                        <span class="cov9" title="5">parts := strings.Split(authHeader, " ")
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov1" title="1">{
                                http.Error(w, `{"error":"Invalid authorization header format"}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov7" title="4">tokenString := parts[1]

                        // Validate token
                        authService := services.NewAuthService(jwtSecret, 24) // expiration not used here
                        claims, err := authService.ValidateJWT(tokenString)
                        if err != nil </span><span class="cov4" title="2">{
                                http.Error(w, fmt.Sprintf(`{"error":"Invalid token: %v"}`, err), http.StatusUnauthorized)
                                return
                        }</span>

                        // Extract claims
                        <span class="cov4" title="2">userID, ok := (*claims)["user_id"].(float64)
                        if !ok </span><span class="cov0" title="0">{
                                http.Error(w, `{"error":"Invalid token claims"}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov4" title="2">email, ok := (*claims)["email"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                http.Error(w, `{"error":"Invalid token claims"}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov4" title="2">isAdmin, ok := (*claims)["is_admin"].(bool)
                        if !ok </span><span class="cov0" title="0">{
                                isAdmin = false
                        }</span>

                        // Add to context
                        <span class="cov4" title="2">ctx := context.WithValue(r.Context(), UserIDKey, int(userID))
                        ctx = context.WithValue(ctx, EmailKey, email)
                        ctx = context.WithValue(ctx, IsAdminKey, isAdmin)

                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// RequireAdmin middleware checks if user is an admin
func RequireAdmin(next http.Handler) http.Handler <span class="cov6" title="3">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov6" title="3">{
                isAdmin, ok := r.Context().Value(IsAdminKey).(bool)
                if !ok || !isAdmin </span><span class="cov4" title="2">{
                        http.Error(w, `{"error":"Admin access required"}`, http.StatusForbidden)
                        return
                }</span>
                <span class="cov1" title="1">next.ServeHTTP(w, r)</span>
        })
}

// SecurityHeadersMiddleware adds security headers
func SecurityHeadersMiddleware(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                // Prevent clickjacking
                w.Header().Set("X-Frame-Options", "DENY")

                // Prevent MIME sniffing
                w.Header().Set("X-Content-Type-Options", "nosniff")

                // Enable XSS protection
                w.Header().Set("X-XSS-Protection", "1; mode=block")

                // Enforce HTTPS in production
                w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")

                // Content Security Policy
                w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:")

                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import "time"

// BlockedDate represents a date that is blocked from bookings
type BlockedDate struct {
        ID        int       `json:"id"`
        Date      string    `json:"date"` // YYYY-MM-DD format
        Reason    string    `json:"reason"`
        CreatedBy int       `json:"created_by"`
        CreatedAt time.Time `json:"created_at"`
}

// CreateBlockedDateRequest represents a request to block a date
type CreateBlockedDateRequest struct {
        Date   string `json:"date"`
        Reason string `json:"reason"`
}

// Validate validates the create blocked date request
func (r *CreateBlockedDateRequest) Validate() error <span class="cov10" title="11">{
        if r.Date == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "date", Message: "Date is required"}
        }</span>

        // Validate date format (YYYY-MM-DD)
        <span class="cov9" title="10">if _, err := time.Parse("2006-01-02", r.Date); err != nil </span><span class="cov7" title="6">{
                return &amp;ValidationError{Field: "date", Message: "Date must be in YYYY-MM-DD format"}
        }</span>

        <span class="cov6" title="4">if r.Reason == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "reason", Message: "Reason is required"}
        }</span>

        <span class="cov5" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import "time"

// Booking represents a dog walking booking
type Booking struct {
        ID                      int        `json:"id"`
        UserID                  int        `json:"user_id"`
        DogID                   int        `json:"dog_id"`
        Date                    string     `json:"date"` // YYYY-MM-DD format
        WalkType                string     `json:"walk_type"`
        ScheduledTime           string     `json:"scheduled_time"` // HH:MM format
        Status                  string     `json:"status"`
        CompletedAt             *time.Time `json:"completed_at,omitempty"`
        UserNotes               *string    `json:"user_notes,omitempty"`
        AdminCancellationReason *string    `json:"admin_cancellation_reason,omitempty"`
        CreatedAt               time.Time  `json:"created_at"`
        UpdatedAt               time.Time  `json:"updated_at"`

        // Joined data for responses
        User *User `json:"user,omitempty"`
        Dog  *Dog  `json:"dog,omitempty"`
}

// CreateBookingRequest represents a request to create a booking
type CreateBookingRequest struct {
        DogID         int    `json:"dog_id"`
        Date          string `json:"date"` // YYYY-MM-DD
        WalkType      string `json:"walk_type"`
        ScheduledTime string `json:"scheduled_time"` // HH:MM
}

// CancelBookingRequest represents a request to cancel a booking
type CancelBookingRequest struct {
        Reason *string `json:"reason,omitempty"` // Optional for users, required for admins
}

// AddNotesRequest represents a request to add notes to a completed booking
type AddNotesRequest struct {
        Notes string `json:"notes"`
}

// MoveBookingRequest represents a request to move a booking to a new date/time
type MoveBookingRequest struct {
        Date          string  `json:"date"`
        WalkType      string  `json:"walk_type"`
        ScheduledTime string  `json:"scheduled_time"`
        Reason        string  `json:"reason"`
}

// Validate validates the move booking request
func (r *MoveBookingRequest) Validate() error <span class="cov6" title="3">{
        if r.Date == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "date", Message: "Date is required"}
        }</span>

        <span class="cov6" title="3">if _, err := time.Parse("2006-01-02", r.Date); err != nil </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "date", Message: "Date must be in YYYY-MM-DD format"}
        }</span>

        <span class="cov4" title="2">if r.WalkType != "morning" &amp;&amp; r.WalkType != "evening" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "walk_type", Message: "Walk type must be 'morning' or 'evening'"}
        }</span>

        <span class="cov4" title="2">if r.ScheduledTime == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "scheduled_time", Message: "Scheduled time is required"}
        }</span>

        <span class="cov4" title="2">if _, err := time.Parse("15:04", r.ScheduledTime); err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "scheduled_time", Message: "Scheduled time must be in HH:MM format"}
        }</span>

        <span class="cov4" title="2">if r.Reason == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "reason", Message: "Reason is required"}
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// BookingFilterRequest represents filters for listing bookings
type BookingFilterRequest struct {
        UserID    *int    `json:"user_id,omitempty"`
        DogID     *int    `json:"dog_id,omitempty"`
        DateFrom  *string `json:"date_from,omitempty"`
        DateTo    *string `json:"date_to,omitempty"`
        Status    *string `json:"status,omitempty"`
        WalkType  *string `json:"walk_type,omitempty"`
        Year      *int    `json:"year,omitempty"`
        Month     *int    `json:"month,omitempty"`
}

// CalendarDay represents a day in the calendar with bookings
type CalendarDay struct {
        Date     string     `json:"date"`
        Bookings []*Booking `json:"bookings"`
        IsBlocked bool      `json:"is_blocked"`
        BlockedReason *string `json:"blocked_reason,omitempty"`
}

// CalendarResponse represents a month view of the calendar
type CalendarResponse struct {
        Year  int            `json:"year"`
        Month int            `json:"month"`
        Days  []*CalendarDay `json:"days"`
}

// Validate validates the create booking request
func (r *CreateBookingRequest) Validate() error <span class="cov10" title="6">{
        if r.DogID &lt;= 0 </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "dog_id", Message: "Dog ID is required"}
        }</span>

        <span class="cov9" title="5">if r.Date == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "date", Message: "Date is required"}
        }</span>

        // Validate date format (YYYY-MM-DD)
        <span class="cov7" title="4">if _, err := time.Parse("2006-01-02", r.Date); err != nil </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "date", Message: "Date must be in YYYY-MM-DD format"}
        }</span>

        <span class="cov6" title="3">if r.WalkType != "morning" &amp;&amp; r.WalkType != "evening" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "walk_type", Message: "Walk type must be 'morning' or 'evening'"}
        }</span>

        <span class="cov4" title="2">if r.ScheduledTime == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "scheduled_time", Message: "Scheduled time is required"}
        }</span>

        // Validate time format (HH:MM)
        <span class="cov4" title="2">if _, err := time.Parse("15:04", r.ScheduledTime); err != nil </span><span class="cov1" title="1">{
                return &amp;ValidationError{Field: "scheduled_time", Message: "Scheduled time must be in HH:MM format"}
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import "fmt"

// ValidationError represents a validation error
type ValidationError struct {
        Field   string
        Message string
}

// Error implements the error interface
func (e *ValidationError) Error() string <span class="cov10" title="18">{
        return fmt.Sprintf("%s: %s", e.Field, e.Message)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import "time"

// ExperienceRequest represents a request for experience level promotion
type ExperienceRequest struct {
        ID             int        `json:"id"`
        UserID         int        `json:"user_id"`
        RequestedLevel string     `json:"requested_level"`
        Status         string     `json:"status"`
        AdminMessage   *string    `json:"admin_message,omitempty"`
        ReviewedBy     *int       `json:"reviewed_by,omitempty"`
        ReviewedAt     *time.Time `json:"reviewed_at,omitempty"`
        CreatedAt      time.Time  `json:"created_at"`

        // Joined data for responses
        User *User `json:"user,omitempty"`
}

// CreateExperienceRequestRequest represents a request to create an experience level request
type CreateExperienceRequestRequest struct {
        RequestedLevel string `json:"requested_level"`
}

// ReviewExperienceRequestRequest represents a request to review an experience request
type ReviewExperienceRequestRequest struct {
        Approved bool    `json:"approved"`
        Message  *string `json:"message,omitempty"`
}

// Validate validates the create experience request
func (r *CreateExperienceRequestRequest) Validate() error <span class="cov10" title="6">{
        if r.RequestedLevel != "blue" &amp;&amp; r.RequestedLevel != "orange" </span><span class="cov7" title="4">{
                return &amp;ValidationError{Field: "requested_level", Message: "Requested level must be 'blue' or 'orange'"}
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// Validate validates the review request
func (r *ReviewExperienceRequestRequest) Validate() error <span class="cov7" title="4">{
        // No specific validation needed, approved is a boolean
        return nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import "time"

// ReactivationRequest represents a request to reactivate a deactivated account
type ReactivationRequest struct {
        ID           int        `json:"id"`
        UserID       int        `json:"user_id"`
        Status       string     `json:"status"`
        AdminMessage *string    `json:"admin_message,omitempty"`
        ReviewedBy   *int       `json:"reviewed_by,omitempty"`
        ReviewedAt   *time.Time `json:"reviewed_at,omitempty"`
        CreatedAt    time.Time  `json:"created_at"`

        // Joined data for responses
        User *User `json:"user,omitempty"`
}

// CreateReactivationRequestRequest represents a request to create a reactivation request
type CreateReactivationRequestRequest struct {
        // No fields needed - user ID comes from auth context
}

// ReviewReactivationRequestRequest represents a request to review a reactivation request
type ReviewReactivationRequestRequest struct {
        Approved bool    `json:"approved"`
        Message  *string `json:"message,omitempty"`
}

// Validate validates the review request
func (r *ReviewReactivationRequestRequest) Validate() error <span class="cov10" title="5">{
        // No specific validation needed
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import "time"

// SystemSetting represents a system configuration setting
type SystemSetting struct {
        Key       string    `json:"key"`
        Value     string    `json:"value"`
        UpdatedAt time.Time `json:"updated_at"`
}

// UpdateSettingRequest represents a request to update a setting
type UpdateSettingRequest struct {
        Value string `json:"value"`
}

// Validate validates the update setting request
func (r *UpdateSettingRequest) Validate() error <span class="cov0" title="0">{
        if r.Value == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "value", Message: "Value is required"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

// DONE: Test helper functions for model tests

// stringPtr returns a pointer to a string
func stringPtr(s string) *string <span class="cov3" title="5">{
        return &amp;s
}</span>

// intPtr returns a pointer to an int
func intPtr(i int) *int <span class="cov0" title="0">{
        return &amp;i
}</span>

// contains checks if a string contains a substring
func contains(s, substr string) bool <span class="cov5" title="18">{
        if len(s) &lt; len(substr) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="18">for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov10" title="338">{
                if s[i:i+len(substr)] == substr </span><span class="cov4" title="12">{
                        return true
                }</span>
        }
        <span class="cov3" title="6">return false</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// BlockedDateRepository handles blocked date database operations
type BlockedDateRepository struct {
        db *sql.DB
}

// NewBlockedDateRepository creates a new blocked date repository
func NewBlockedDateRepository(db *sql.DB) *BlockedDateRepository <span class="cov10" title="5">{
        return &amp;BlockedDateRepository{db: db}
}</span>

// Create creates a new blocked date
func (r *BlockedDateRepository) Create(blockedDate *models.BlockedDate) error <span class="cov7" title="3">{
        query := `
                INSERT INTO blocked_dates (date, reason, created_by, created_at)
                VALUES (?, ?, ?, ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query,
                blockedDate.Date,
                blockedDate.Reason,
                blockedDate.CreatedBy,
                now,
        )

        if err != nil </span><span class="cov1" title="1">{
                // Check for unique constraint violation
                if err.Error() == "UNIQUE constraint failed: blocked_dates.date" </span><span class="cov1" title="1">{
                        return fmt.Errorf("date is already blocked")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create blocked date: %w", err)</span>
        }

        <span class="cov4" title="2">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get blocked date ID: %w", err)
        }</span>

        <span class="cov4" title="2">blockedDate.ID = int(id)
        blockedDate.CreatedAt = now

        return nil</span>
}

// FindAll finds all blocked dates
func (r *BlockedDateRepository) FindAll() ([]*models.BlockedDate, error) <span class="cov4" title="2">{
        query := `
                SELECT id, date, reason, created_by, created_at
                FROM blocked_dates
                ORDER BY date ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query blocked dates: %w", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        blockedDates := []*models.BlockedDate{}
        for rows.Next() </span><span class="cov4" title="2">{
                blockedDate := &amp;models.BlockedDate{}
                err := rows.Scan(
                        &amp;blockedDate.ID,
                        &amp;blockedDate.Date,
                        &amp;blockedDate.Reason,
                        &amp;blockedDate.CreatedBy,
                        &amp;blockedDate.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blocked date: %w", err)
                }</span>
                <span class="cov4" title="2">blockedDates = append(blockedDates, blockedDate)</span>
        }

        <span class="cov4" title="2">return blockedDates, nil</span>
}

// FindByDate finds a blocked date by date
func (r *BlockedDateRepository) FindByDate(date string) (*models.BlockedDate, error) <span class="cov4" title="2">{
        query := `
                SELECT id, date, reason, created_by, created_at
                FROM blocked_dates
                WHERE date = ?
        `

        blockedDate := &amp;models.BlockedDate{}
        err := r.db.QueryRow(query, date).Scan(
                &amp;blockedDate.ID,
                &amp;blockedDate.Date,
                &amp;blockedDate.Reason,
                &amp;blockedDate.CreatedBy,
                &amp;blockedDate.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find blocked date: %w", err)
        }</span>

        <span class="cov1" title="1">return blockedDate, nil</span>
}

// Delete deletes a blocked date
func (r *BlockedDateRepository) Delete(id int) error <span class="cov4" title="2">{
        query := `DELETE FROM blocked_dates WHERE id = ?`

        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete blocked date: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// IsBlocked checks if a date is blocked
func (r *BlockedDateRepository) IsBlocked(date string) (bool, error) <span class="cov8" title="4">{
        query := `SELECT COUNT(*) FROM blocked_dates WHERE date = ?`

        var count int
        err := r.db.QueryRow(query, date).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check if date is blocked: %w", err)
        }</span>

        <span class="cov8" title="4">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// BookingRepository handles booking database operations
type BookingRepository struct {
        db *sql.DB
}

// NewBookingRepository creates a new booking repository
func NewBookingRepository(db *sql.DB) *BookingRepository <span class="cov8" title="9">{
        return &amp;BookingRepository{db: db}
}</span>

// Create creates a new booking
func (r *BookingRepository) Create(booking *models.Booking) error <span class="cov10" title="14">{
        query := `
                INSERT INTO bookings (user_id, dog_id, date, walk_type, scheduled_time, status, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query,
                booking.UserID,
                booking.DogID,
                booking.Date,
                booking.WalkType,
                booking.ScheduledTime,
                "scheduled",
                now,
                now,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create booking: %w", err)
        }</span>

        <span class="cov10" title="14">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get booking ID: %w", err)
        }</span>

        <span class="cov10" title="14">booking.ID = int(id)
        booking.Status = "scheduled"
        booking.CreatedAt = now
        booking.UpdatedAt = now

        return nil</span>
}

// FindByID finds a booking by ID
func (r *BookingRepository) FindByID(id int) (*models.Booking, error) <span class="cov6" title="5">{
        query := `
                SELECT id, user_id, dog_id, date, walk_type, scheduled_time, status,
                       completed_at, user_notes, admin_cancellation_reason, created_at, updated_at
                FROM bookings
                WHERE id = ?
        `

        booking := &amp;models.Booking{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;booking.ID,
                &amp;booking.UserID,
                &amp;booking.DogID,
                &amp;booking.Date,
                &amp;booking.WalkType,
                &amp;booking.ScheduledTime,
                &amp;booking.Status,
                &amp;booking.CompletedAt,
                &amp;booking.UserNotes,
                &amp;booking.AdminCancellationReason,
                &amp;booking.CreatedAt,
                &amp;booking.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov5" title="4">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find booking: %w", err)
        }</span>

        <span class="cov5" title="4">return booking, nil</span>
}

// FindAll finds all bookings with optional filters
func (r *BookingRepository) FindAll(filter *models.BookingFilterRequest) ([]*models.Booking, error) <span class="cov4" title="3">{
        query := `
                SELECT id, user_id, dog_id, date, walk_type, scheduled_time, status,
                       completed_at, user_notes, admin_cancellation_reason, created_at, updated_at
                FROM bookings
                WHERE 1=1
        `
        args := []interface{}{}

        if filter != nil </span><span class="cov3" title="2">{
                if filter.UserID != nil </span><span class="cov1" title="1">{
                        query += " AND user_id = ?"
                        args = append(args, *filter.UserID)
                }</span>

                <span class="cov3" title="2">if filter.DogID != nil </span><span class="cov0" title="0">{
                        query += " AND dog_id = ?"
                        args = append(args, *filter.DogID)
                }</span>

                <span class="cov3" title="2">if filter.DateFrom != nil </span><span class="cov0" title="0">{
                        query += " AND date &gt;= ?"
                        args = append(args, *filter.DateFrom)
                }</span>

                <span class="cov3" title="2">if filter.DateTo != nil </span><span class="cov0" title="0">{
                        query += " AND date &lt;= ?"
                        args = append(args, *filter.DateTo)
                }</span>

                <span class="cov3" title="2">if filter.Status != nil </span><span class="cov1" title="1">{
                        query += " AND status = ?"
                        args = append(args, *filter.Status)
                }</span>

                <span class="cov3" title="2">if filter.WalkType != nil </span><span class="cov0" title="0">{
                        query += " AND walk_type = ?"
                        args = append(args, *filter.WalkType)
                }</span>

                <span class="cov3" title="2">if filter.Year != nil &amp;&amp; filter.Month != nil </span><span class="cov0" title="0">{
                        // Filter by year and month
                        startDate := fmt.Sprintf("%d-%02d-01", *filter.Year, *filter.Month)
                        // Calculate last day of month
                        nextMonth := time.Date(*filter.Year, time.Month(*filter.Month+1), 1, 0, 0, 0, 0, time.UTC)
                        endDate := nextMonth.Add(-24 * time.Hour).Format("2006-01-02")

                        query += " AND date &gt;= ? AND date &lt;= ?"
                        args = append(args, startDate, endDate)
                }</span>
        }

        <span class="cov4" title="3">query += " ORDER BY date ASC, scheduled_time ASC"

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query bookings: %w", err)
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        bookings := []*models.Booking{}
        for rows.Next() </span><span class="cov8" title="8">{
                booking := &amp;models.Booking{}
                err := rows.Scan(
                        &amp;booking.ID,
                        &amp;booking.UserID,
                        &amp;booking.DogID,
                        &amp;booking.Date,
                        &amp;booking.WalkType,
                        &amp;booking.ScheduledTime,
                        &amp;booking.Status,
                        &amp;booking.CompletedAt,
                        &amp;booking.UserNotes,
                        &amp;booking.AdminCancellationReason,
                        &amp;booking.CreatedAt,
                        &amp;booking.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan booking: %w", err)
                }</span>
                <span class="cov8" title="8">bookings = append(bookings, booking)</span>
        }

        <span class="cov4" title="3">return bookings, nil</span>
}

// Cancel cancels a booking
func (r *BookingRepository) Cancel(id int, reason *string) error <span class="cov1" title="1">{
        query := `
                UPDATE bookings
                SET status = ?, admin_cancellation_reason = ?, updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query, "cancelled", reason, time.Now(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cancel booking: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// AddNotes adds notes to a completed booking
func (r *BookingRepository) AddNotes(id int, notes string) error <span class="cov1" title="1">{
        query := `
                UPDATE bookings
                SET user_notes = ?, updated_at = ?
                WHERE id = ? AND status = 'completed'
        `

        result, err := r.db.Exec(query, notes, time.Now(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add notes: %w", err)
        }</span>

        <span class="cov1" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("booking not found or not completed")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// CheckDoubleBooking checks if a dog is already booked for the given date and walk type
func (r *BookingRepository) CheckDoubleBooking(dogID int, date, walkType string) (bool, error) <span class="cov3" title="2">{
        query := `
                SELECT COUNT(*)
                FROM bookings
                WHERE dog_id = ? AND date = ? AND walk_type = ? AND status = 'scheduled'
        `

        var count int
        err := r.db.QueryRow(query, dogID, date, walkType).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check double booking: %w", err)
        }</span>

        <span class="cov3" title="2">return count &gt; 0, nil</span>
}

// AutoComplete marks all past scheduled bookings as completed
func (r *BookingRepository) AutoComplete() (int, error) <span class="cov1" title="1">{
        // Get current date and time
        now := time.Now()
        currentDate := now.Format("2006-01-02")
        currentTime := now.Format("15:04")

        query := `
                UPDATE bookings
                SET status = 'completed', completed_at = ?, updated_at = ?
                WHERE status = 'scheduled'
                AND (
                        date &lt; ?
                        OR (date = ? AND scheduled_time &lt; ?)
                )
        `

        result, err := r.db.Exec(query, now, now, currentDate, currentDate, currentTime)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to auto-complete bookings: %w", err)
        }</span>

        <span class="cov1" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">return int(rows), nil</span>
}

// GetUpcoming gets upcoming bookings for a user
func (r *BookingRepository) GetUpcoming(userID int, limit int) ([]*models.Booking, error) <span class="cov3" title="2">{
        query := `
                SELECT id, user_id, dog_id, date, walk_type, scheduled_time, status,
                       completed_at, user_notes, admin_cancellation_reason, created_at, updated_at
                FROM bookings
                WHERE user_id = ? AND status = 'scheduled' AND date &gt;= ?
                ORDER BY date ASC, scheduled_time ASC
                LIMIT ?
        `

        currentDate := time.Now().Format("2006-01-02")
        rows, err := r.db.Query(query, userID, currentDate, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query upcoming bookings: %w", err)
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        bookings := []*models.Booking{}
        for rows.Next() </span><span class="cov4" title="3">{
                booking := &amp;models.Booking{}
                err := rows.Scan(
                        &amp;booking.ID,
                        &amp;booking.UserID,
                        &amp;booking.DogID,
                        &amp;booking.Date,
                        &amp;booking.WalkType,
                        &amp;booking.ScheduledTime,
                        &amp;booking.Status,
                        &amp;booking.CompletedAt,
                        &amp;booking.UserNotes,
                        &amp;booking.AdminCancellationReason,
                        &amp;booking.CreatedAt,
                        &amp;booking.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan booking: %w", err)
                }</span>
                <span class="cov4" title="3">bookings = append(bookings, booking)</span>
        }

        <span class="cov3" title="2">return bookings, nil</span>
}

// GetForReminders gets bookings that need reminders (1 hour before scheduled time)
func (r *BookingRepository) GetForReminders() ([]*models.Booking, error) <span class="cov0" title="0">{
        // Get bookings scheduled within the next 1-2 hours
        now := time.Now()
        oneHourFromNow := now.Add(1 * time.Hour)
        twoHoursFromNow := now.Add(2 * time.Hour)

        currentDate := now.Format("2006-01-02")
        oneHourTime := oneHourFromNow.Format("15:04")
        twoHoursTime := twoHoursFromNow.Format("15:04")

        query := `
                SELECT id, user_id, dog_id, date, walk_type, scheduled_time, status,
                       completed_at, user_notes, admin_cancellation_reason, created_at, updated_at
                FROM bookings
                WHERE status = 'scheduled'
                AND date = ?
                AND scheduled_time &gt;= ?
                AND scheduled_time &lt; ?
        `

        rows, err := r.db.Query(query, currentDate, oneHourTime, twoHoursTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query bookings for reminders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        bookings := []*models.Booking{}
        for rows.Next() </span><span class="cov0" title="0">{
                booking := &amp;models.Booking{}
                err := rows.Scan(
                        &amp;booking.ID,
                        &amp;booking.UserID,
                        &amp;booking.DogID,
                        &amp;booking.Date,
                        &amp;booking.WalkType,
                        &amp;booking.ScheduledTime,
                        &amp;booking.Status,
                        &amp;booking.CompletedAt,
                        &amp;booking.UserNotes,
                        &amp;booking.AdminCancellationReason,
                        &amp;booking.CreatedAt,
                        &amp;booking.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan booking: %w", err)
                }</span>
                <span class="cov0" title="0">bookings = append(bookings, booking)</span>
        }

        <span class="cov0" title="0">return bookings, nil</span>
}

// Update updates a booking (for admin to move bookings)
func (r *BookingRepository) Update(booking *models.Booking) error <span class="cov1" title="1">{
        query := `
                UPDATE bookings
                SET date = ?, walk_type = ?, scheduled_time = ?, updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                booking.Date,
                booking.WalkType,
                booking.ScheduledTime,
                time.Now(),
                booking.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update booking: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FindByIDWithDetails finds a booking by ID with user and dog details
func (r *BookingRepository) FindByIDWithDetails(id int) (*models.Booking, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        b.id, b.user_id, b.dog_id, b.date, b.walk_type, b.scheduled_time, b.status,
                        b.completed_at, b.user_notes, b.admin_cancellation_reason, b.created_at, b.updated_at,
                        u.name as user_name, u.email as user_email, u.phone as user_phone,
                        d.name as dog_name, d.breed, d.size, d.age
                FROM bookings b
                LEFT JOIN users u ON b.user_id = u.id
                LEFT JOIN dogs d ON b.dog_id = d.id
                WHERE b.id = ?
        `

        booking := &amp;models.Booking{
                User: &amp;models.User{},
                Dog:  &amp;models.Dog{},
        }

        var userName, userEmail, userPhone sql.NullString
        var dogName, breed, size string
        var age int

        err := r.db.QueryRow(query, id).Scan(
                &amp;booking.ID,
                &amp;booking.UserID,
                &amp;booking.DogID,
                &amp;booking.Date,
                &amp;booking.WalkType,
                &amp;booking.ScheduledTime,
                &amp;booking.Status,
                &amp;booking.CompletedAt,
                &amp;booking.UserNotes,
                &amp;booking.AdminCancellationReason,
                &amp;booking.CreatedAt,
                &amp;booking.UpdatedAt,
                &amp;userName,
                &amp;userEmail,
                &amp;userPhone,
                &amp;dogName,
                &amp;breed,
                &amp;size,
                &amp;age,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find booking with details: %w", err)
        }</span>

        // Populate user details
        <span class="cov0" title="0">if userName.Valid </span><span class="cov0" title="0">{
                booking.User.Name = userName.String
        }</span> else<span class="cov0" title="0"> {
                booking.User.Name = "Deleted User"
        }</span>
        <span class="cov0" title="0">if userEmail.Valid </span><span class="cov0" title="0">{
                email := userEmail.String
                booking.User.Email = &amp;email
        }</span>
        <span class="cov0" title="0">if userPhone.Valid </span><span class="cov0" title="0">{
                phone := userPhone.String
                booking.User.Phone = &amp;phone
        }</span>

        // Populate dog details
        <span class="cov0" title="0">booking.Dog.Name = dogName
        booking.Dog.Breed = breed
        booking.Dog.Size = size
        booking.Dog.Age = age

        return booking, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "strings"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// DogRepository handles dog database operations
type DogRepository struct {
        db *sql.DB
}

// NewDogRepository creates a new dog repository
func NewDogRepository(db *sql.DB) *DogRepository <span class="cov10" title="8">{
        return &amp;DogRepository{db: db}
}</span>

// Create creates a new dog
func (r *DogRepository) Create(dog *models.Dog) error <span class="cov4" title="2">{
        query := `
                INSERT INTO dogs (
                        name, breed, size, age, category, special_needs,
                        pickup_location, walk_route, walk_duration, special_instructions,
                        default_morning_time, default_evening_time, is_available
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                dog.Name,
                dog.Breed,
                dog.Size,
                dog.Age,
                dog.Category,
                dog.SpecialNeeds,
                dog.PickupLocation,
                dog.WalkRoute,
                dog.WalkDuration,
                dog.SpecialInstructions,
                dog.DefaultMorningTime,
                dog.DefaultEveningTime,
                dog.IsAvailable,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dog: %w", err)
        }</span>

        <span class="cov4" title="2">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dog ID: %w", err)
        }</span>

        <span class="cov4" title="2">dog.ID = int(id)
        dog.CreatedAt = time.Now()
        dog.UpdatedAt = time.Now()
        return nil</span>
}

// FindByID finds a dog by ID
func (r *DogRepository) FindByID(id int) (*models.Dog, error) <span class="cov9" title="7">{
        query := `
                SELECT id, name, breed, size, age, category, photo, special_needs,
                       pickup_location, walk_route, walk_duration, special_instructions,
                       default_morning_time, default_evening_time, is_available,
                       unavailable_reason, unavailable_since, created_at, updated_at
                FROM dogs
                WHERE id = ?
        `

        dog := &amp;models.Dog{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;dog.ID,
                &amp;dog.Name,
                &amp;dog.Breed,
                &amp;dog.Size,
                &amp;dog.Age,
                &amp;dog.Category,
                &amp;dog.Photo,
                &amp;dog.SpecialNeeds,
                &amp;dog.PickupLocation,
                &amp;dog.WalkRoute,
                &amp;dog.WalkDuration,
                &amp;dog.SpecialInstructions,
                &amp;dog.DefaultMorningTime,
                &amp;dog.DefaultEveningTime,
                &amp;dog.IsAvailable,
                &amp;dog.UnavailableReason,
                &amp;dog.UnavailableSince,
                &amp;dog.CreatedAt,
                &amp;dog.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov4" title="2">{
                return nil, nil
        }</span>
        <span class="cov7" title="5">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find dog: %w", err)
        }</span>

        <span class="cov7" title="5">return dog, nil</span>
}

// FindAll finds all dogs with optional filtering
func (r *DogRepository) FindAll(filter *models.DogFilterRequest) ([]*models.Dog, error) <span class="cov5" title="3">{
        query := `
                SELECT id, name, breed, size, age, category, photo, special_needs,
                       pickup_location, walk_route, walk_duration, special_instructions,
                       default_morning_time, default_evening_time, is_available,
                       unavailable_reason, unavailable_since, created_at, updated_at
                FROM dogs
                WHERE 1=1
        `

        args := []interface{}{}

        // Apply filters
        if filter != nil </span><span class="cov4" title="2">{
                if filter.Breed != nil &amp;&amp; *filter.Breed != "" </span><span class="cov0" title="0">{
                        query += " AND LOWER(breed) = LOWER(?)"
                        args = append(args, *filter.Breed)
                }</span>

                <span class="cov4" title="2">if filter.Size != nil &amp;&amp; *filter.Size != "" </span><span class="cov0" title="0">{
                        query += " AND size = ?"
                        args = append(args, *filter.Size)
                }</span>

                <span class="cov4" title="2">if filter.MinAge != nil </span><span class="cov0" title="0">{
                        query += " AND age &gt;= ?"
                        args = append(args, *filter.MinAge)
                }</span>

                <span class="cov4" title="2">if filter.MaxAge != nil </span><span class="cov0" title="0">{
                        query += " AND age &lt;= ?"
                        args = append(args, *filter.MaxAge)
                }</span>

                <span class="cov4" title="2">if filter.Category != nil &amp;&amp; *filter.Category != "" </span><span class="cov1" title="1">{
                        query += " AND category = ?"
                        args = append(args, *filter.Category)
                }</span>

                <span class="cov4" title="2">if filter.Available != nil </span><span class="cov1" title="1">{
                        query += " AND is_available = ?"
                        args = append(args, *filter.Available)
                }</span>

                <span class="cov4" title="2">if filter.Search != nil &amp;&amp; *filter.Search != "" </span><span class="cov0" title="0">{
                        query += " AND (LOWER(name) LIKE LOWER(?) OR LOWER(breed) LIKE LOWER(?))"
                        searchTerm := "%" + *filter.Search + "%"
                        args = append(args, searchTerm, searchTerm)
                }</span>
        }

        <span class="cov5" title="3">query += " ORDER BY name ASC"

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query dogs: %w", err)
        }</span>
        <span class="cov5" title="3">defer rows.Close()

        dogs := []*models.Dog{}
        for rows.Next() </span><span class="cov9" title="7">{
                dog := &amp;models.Dog{}
                err := rows.Scan(
                        &amp;dog.ID,
                        &amp;dog.Name,
                        &amp;dog.Breed,
                        &amp;dog.Size,
                        &amp;dog.Age,
                        &amp;dog.Category,
                        &amp;dog.Photo,
                        &amp;dog.SpecialNeeds,
                        &amp;dog.PickupLocation,
                        &amp;dog.WalkRoute,
                        &amp;dog.WalkDuration,
                        &amp;dog.SpecialInstructions,
                        &amp;dog.DefaultMorningTime,
                        &amp;dog.DefaultEveningTime,
                        &amp;dog.IsAvailable,
                        &amp;dog.UnavailableReason,
                        &amp;dog.UnavailableSince,
                        &amp;dog.CreatedAt,
                        &amp;dog.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan dog: %w", err)
                }</span>
                <span class="cov9" title="7">dogs = append(dogs, dog)</span>
        }

        <span class="cov5" title="3">return dogs, nil</span>
}

// Update updates a dog
func (r *DogRepository) Update(dog *models.Dog) error <span class="cov1" title="1">{
        query := `
                UPDATE dogs SET
                        name = ?,
                        breed = ?,
                        size = ?,
                        age = ?,
                        category = ?,
                        photo = ?,
                        special_needs = ?,
                        pickup_location = ?,
                        walk_route = ?,
                        walk_duration = ?,
                        special_instructions = ?,
                        default_morning_time = ?,
                        default_evening_time = ?,
                        is_available = ?,
                        unavailable_reason = ?,
                        unavailable_since = ?,
                        updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(
                query,
                dog.Name,
                dog.Breed,
                dog.Size,
                dog.Age,
                dog.Category,
                dog.Photo,
                dog.SpecialNeeds,
                dog.PickupLocation,
                dog.WalkRoute,
                dog.WalkDuration,
                dog.SpecialInstructions,
                dog.DefaultMorningTime,
                dog.DefaultEveningTime,
                dog.IsAvailable,
                dog.UnavailableReason,
                dog.UnavailableSince,
                time.Now(),
                dog.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update dog: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Delete deletes a dog (only if no future bookings exist)
func (r *DogRepository) Delete(id int) error <span class="cov4" title="2">{
        // Check for future bookings
        checkQuery := `
                SELECT COUNT(*) FROM bookings
                WHERE dog_id = ? AND date &gt;= date('now') AND status = 'scheduled'
        `

        var count int
        err := r.db.QueryRow(checkQuery, id).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check bookings: %w", err)
        }</span>

        <span class="cov4" title="2">if count &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete dog with future bookings")
        }</span>

        // Delete the dog
        <span class="cov4" title="2">deleteQuery := `DELETE FROM dogs WHERE id = ?`
        _, err = r.db.Exec(deleteQuery, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete dog: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// ToggleAvailability toggles a dog's availability status
func (r *DogRepository) ToggleAvailability(id int, isAvailable bool, reason *string) error <span class="cov5" title="3">{
        var query string
        var args []interface{}

        if isAvailable </span><span class="cov1" title="1">{
                // Mark as available (clear reason and timestamp)
                query = `
                        UPDATE dogs SET
                                is_available = 1,
                                unavailable_reason = NULL,
                                unavailable_since = NULL,
                                updated_at = ?
                        WHERE id = ?
                `
                args = []interface{}{time.Now(), id}
        }</span> else<span class="cov4" title="2"> {
                // Mark as unavailable
                query = `
                        UPDATE dogs SET
                                is_available = 0,
                                unavailable_reason = ?,
                                unavailable_since = ?,
                                updated_at = ?
                        WHERE id = ?
                `
                now := time.Now()
                args = []interface{}{reason, now, now, id}
        }</span>

        <span class="cov5" title="3">_, err := r.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to toggle availability: %w", err)
        }</span>

        <span class="cov5" title="3">return nil</span>
}

// GetBreeds returns a list of unique breeds
func (r *DogRepository) GetBreeds() ([]string, error) <span class="cov4" title="2">{
        query := `SELECT DISTINCT breed FROM dogs ORDER BY breed ASC`

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get breeds: %w", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        breeds := []string{}
        for rows.Next() </span><span class="cov4" title="2">{
                var breed string
                if err := rows.Scan(&amp;breed); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan breed: %w", err)
                }</span>
                <span class="cov4" title="2">breeds = append(breeds, breed)</span>
        }

        <span class="cov4" title="2">return breeds, nil</span>
}

// CanUserAccessDog checks if a user can access a dog based on their experience level
func CanUserAccessDog(userLevel, dogCategory string) bool <span class="cov0" title="0">{
        // Define level hierarchy: green &lt; blue &lt; orange
        levelOrder := map[string]int{
                "green":  1,
                "blue":   2,
                "orange": 3,
        }

        userLevelNum, userOk := levelOrder[strings.ToLower(userLevel)]
        dogLevelNum, dogOk := levelOrder[strings.ToLower(dogCategory)]

        if !userOk || !dogOk </span><span class="cov0" title="0">{
                return false
        }</span>

        // User can access dog if their level is &gt;= dog's required level
        <span class="cov0" title="0">return userLevelNum &gt;= dogLevelNum</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// ExperienceRequestRepository handles experience request database operations
type ExperienceRequestRepository struct {
        db *sql.DB
}

// NewExperienceRequestRepository creates a new experience request repository
func NewExperienceRequestRepository(db *sql.DB) *ExperienceRequestRepository <span class="cov10" title="7">{
        return &amp;ExperienceRequestRepository{db: db}
}</span>

// Create creates a new experience request
func (r *ExperienceRequestRepository) Create(request *models.ExperienceRequest) error <span class="cov1" title="1">{
        query := `
                INSERT INTO experience_requests (user_id, requested_level, status, created_at)
                VALUES (?, ?, 'pending', ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query, request.UserID, request.RequestedLevel, now)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create experience request: %w", err)
        }</span>

        <span class="cov1" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get request ID: %w", err)
        }</span>

        <span class="cov1" title="1">request.ID = int(id)
        request.Status = "pending"
        request.CreatedAt = now

        return nil</span>
}

// FindByID finds an experience request by ID
func (r *ExperienceRequestRepository) FindByID(id int) (*models.ExperienceRequest, error) <span class="cov7" title="4">{
        query := `
                SELECT id, user_id, requested_level, status, admin_message, reviewed_by, reviewed_at, created_at
                FROM experience_requests
                WHERE id = ?
        `

        request := &amp;models.ExperienceRequest{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;request.ID,
                &amp;request.UserID,
                &amp;request.RequestedLevel,
                &amp;request.Status,
                &amp;request.AdminMessage,
                &amp;request.ReviewedBy,
                &amp;request.ReviewedAt,
                &amp;request.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov6" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find experience request: %w", err)
        }</span>

        <span class="cov6" title="3">return request, nil</span>
}

// FindByUserID finds experience requests by user ID
func (r *ExperienceRequestRepository) FindByUserID(userID int) ([]*models.ExperienceRequest, error) <span class="cov4" title="2">{
        query := `
                SELECT id, user_id, requested_level, status, admin_message, reviewed_by, reviewed_at, created_at
                FROM experience_requests
                WHERE user_id = ?
                ORDER BY created_at DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query experience requests: %w", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        requests := []*models.ExperienceRequest{}
        for rows.Next() </span><span class="cov4" title="2">{
                request := &amp;models.ExperienceRequest{}
                err := rows.Scan(
                        &amp;request.ID,
                        &amp;request.UserID,
                        &amp;request.RequestedLevel,
                        &amp;request.Status,
                        &amp;request.AdminMessage,
                        &amp;request.ReviewedBy,
                        &amp;request.ReviewedAt,
                        &amp;request.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan experience request: %w", err)
                }</span>
                <span class="cov4" title="2">requests = append(requests, request)</span>
        }

        <span class="cov4" title="2">return requests, nil</span>
}

// FindAllPending finds all pending experience requests
func (r *ExperienceRequestRepository) FindAllPending() ([]*models.ExperienceRequest, error) <span class="cov1" title="1">{
        query := `
                SELECT id, user_id, requested_level, status, admin_message, reviewed_by, reviewed_at, created_at
                FROM experience_requests
                WHERE status = 'pending'
                ORDER BY created_at ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query pending requests: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        requests := []*models.ExperienceRequest{}
        for rows.Next() </span><span class="cov4" title="2">{
                request := &amp;models.ExperienceRequest{}
                err := rows.Scan(
                        &amp;request.ID,
                        &amp;request.UserID,
                        &amp;request.RequestedLevel,
                        &amp;request.Status,
                        &amp;request.AdminMessage,
                        &amp;request.ReviewedBy,
                        &amp;request.ReviewedAt,
                        &amp;request.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan experience request: %w", err)
                }</span>
                <span class="cov4" title="2">requests = append(requests, request)</span>
        }

        <span class="cov1" title="1">return requests, nil</span>
}

// Approve approves an experience request
func (r *ExperienceRequestRepository) Approve(id int, reviewerID int, message *string) error <span class="cov1" title="1">{
        query := `
                UPDATE experience_requests
                SET status = 'approved', reviewed_by = ?, reviewed_at = ?, admin_message = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, reviewerID, now, message, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to approve request: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Deny denies an experience request
func (r *ExperienceRequestRepository) Deny(id int, reviewerID int, message *string) error <span class="cov1" title="1">{
        query := `
                UPDATE experience_requests
                SET status = 'denied', reviewed_by = ?, reviewed_at = ?, admin_message = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, reviewerID, now, message, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deny request: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// HasPendingRequest checks if user has a pending request for a level
func (r *ExperienceRequestRepository) HasPendingRequest(userID int, level string) (bool, error) <span class="cov6" title="3">{
        query := `
                SELECT COUNT(*)
                FROM experience_requests
                WHERE user_id = ? AND requested_level = ? AND status = 'pending'
        `

        var count int
        err := r.db.QueryRow(query, userID, level).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check pending request: %w", err)
        }</span>

        <span class="cov6" title="3">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// ReactivationRequestRepository handles reactivation request database operations
type ReactivationRequestRepository struct {
        db *sql.DB
}

// NewReactivationRequestRepository creates a new reactivation request repository
func NewReactivationRequestRepository(db *sql.DB) *ReactivationRequestRepository <span class="cov9" title="7">{
        return &amp;ReactivationRequestRepository{db: db}
}</span>

// Create creates a new reactivation request
func (r *ReactivationRequestRepository) Create(request *models.ReactivationRequest) error <span class="cov10" title="8">{
        query := `
                INSERT INTO reactivation_requests (user_id, status, created_at)
                VALUES (?, 'pending', ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query, request.UserID, now)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create reactivation request: %w", err)
        }</span>

        <span class="cov10" title="8">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get request ID: %w", err)
        }</span>

        <span class="cov10" title="8">request.ID = int(id)
        request.Status = "pending"
        request.CreatedAt = now

        return nil</span>
}

// FindByID finds a reactivation request by ID
func (r *ReactivationRequestRepository) FindByID(id int) (*models.ReactivationRequest, error) <span class="cov7" title="4">{
        query := `
                SELECT id, user_id, status, admin_message, reviewed_by, reviewed_at, created_at
                FROM reactivation_requests
                WHERE id = ?
        `

        request := &amp;models.ReactivationRequest{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;request.ID,
                &amp;request.UserID,
                &amp;request.Status,
                &amp;request.AdminMessage,
                &amp;request.ReviewedBy,
                &amp;request.ReviewedAt,
                &amp;request.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov5" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find reactivation request: %w", err)
        }</span>

        <span class="cov5" title="3">return request, nil</span>
}

// FindAllPending finds all pending reactivation requests
func (r *ReactivationRequestRepository) FindAllPending() ([]*models.ReactivationRequest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, status, admin_message, reviewed_by, reviewed_at, created_at
                FROM reactivation_requests
                WHERE status = 'pending'
                ORDER BY created_at ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query pending requests: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        requests := []*models.ReactivationRequest{}
        for rows.Next() </span><span class="cov0" title="0">{
                request := &amp;models.ReactivationRequest{}
                err := rows.Scan(
                        &amp;request.ID,
                        &amp;request.UserID,
                        &amp;request.Status,
                        &amp;request.AdminMessage,
                        &amp;request.ReviewedBy,
                        &amp;request.ReviewedAt,
                        &amp;request.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan reactivation request: %w", err)
                }</span>
                <span class="cov0" title="0">requests = append(requests, request)</span>
        }

        <span class="cov0" title="0">return requests, nil</span>
}

// Approve approves a reactivation request
func (r *ReactivationRequestRepository) Approve(id int, reviewerID int, message *string) error <span class="cov1" title="1">{
        query := `
                UPDATE reactivation_requests
                SET status = 'approved', reviewed_by = ?, reviewed_at = ?, admin_message = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, reviewerID, now, message, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to approve request: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Deny denies a reactivation request
func (r *ReactivationRequestRepository) Deny(id int, reviewerID int, message *string) error <span class="cov1" title="1">{
        query := `
                UPDATE reactivation_requests
                SET status = 'denied', reviewed_by = ?, reviewed_at = ?, admin_message = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, reviewerID, now, message, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deny request: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// HasPendingRequest checks if user has a pending reactivation request
func (r *ReactivationRequestRepository) HasPendingRequest(userID int) (bool, error) <span class="cov4" title="2">{
        query := `
                SELECT COUNT(*)
                FROM reactivation_requests
                WHERE user_id = ? AND status = 'pending'
        `

        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check pending request: %w", err)
        }</span>

        <span class="cov4" title="2">return count &gt; 0, nil</span>
}

// FindByUserID finds reactivation requests by user ID
func (r *ReactivationRequestRepository) FindByUserID(userID int) ([]*models.ReactivationRequest, error) <span class="cov4" title="2">{
        query := `
                SELECT id, user_id, status, admin_message, reviewed_by, reviewed_at, created_at
                FROM reactivation_requests
                WHERE user_id = ?
                ORDER BY created_at DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query reactivation requests: %w", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        requests := []*models.ReactivationRequest{}
        for rows.Next() </span><span class="cov4" title="2">{
                request := &amp;models.ReactivationRequest{}
                err := rows.Scan(
                        &amp;request.ID,
                        &amp;request.UserID,
                        &amp;request.Status,
                        &amp;request.AdminMessage,
                        &amp;request.ReviewedBy,
                        &amp;request.ReviewedAt,
                        &amp;request.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan reactivation request: %w", err)
                }</span>
                <span class="cov4" title="2">requests = append(requests, request)</span>
        }

        <span class="cov4" title="2">return requests, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// SettingsRepository handles system settings database operations
type SettingsRepository struct {
        db *sql.DB
}

// NewSettingsRepository creates a new settings repository
func NewSettingsRepository(db *sql.DB) *SettingsRepository <span class="cov7" title="4">{
        return &amp;SettingsRepository{db: db}
}</span>

// Get retrieves a setting by key
func (r *SettingsRepository) Get(key string) (*models.SystemSetting, error) <span class="cov9" title="5">{
        query := `
                SELECT key, value, updated_at
                FROM system_settings
                WHERE key = ?
        `

        setting := &amp;models.SystemSetting{}
        err := r.db.QueryRow(query, key).Scan(
                &amp;setting.Key,
                &amp;setting.Value,
                &amp;setting.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov4" title="2">{
                return nil, nil
        }</span>

        <span class="cov6" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get setting: %w", err)
        }</span>

        <span class="cov6" title="3">return setting, nil</span>
}

// GetAll retrieves all settings
func (r *SettingsRepository) GetAll() ([]*models.SystemSetting, error) <span class="cov4" title="2">{
        query := `
                SELECT key, value, updated_at
                FROM system_settings
                ORDER BY key ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query settings: %w", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        settings := []*models.SystemSetting{}
        for rows.Next() </span><span class="cov10" title="6">{
                setting := &amp;models.SystemSetting{}
                err := rows.Scan(
                        &amp;setting.Key,
                        &amp;setting.Value,
                        &amp;setting.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan setting: %w", err)
                }</span>
                <span class="cov10" title="6">settings = append(settings, setting)</span>
        }

        <span class="cov4" title="2">return settings, nil</span>
}

// Update updates a setting value
func (r *SettingsRepository) Update(key, value string) error <span class="cov6" title="3">{
        query := `
                UPDATE system_settings
                SET value = ?, updated_at = ?
                WHERE key = ?
        `

        result, err := r.db.Exec(query, value, time.Now(), key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update setting: %w", err)
        }</span>

        <span class="cov6" title="3">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>

        <span class="cov6" title="3">if rows == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("setting not found")
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/tranm/gassigeher/internal/models"
)

// UserRepository handles user database operations
type UserRepository struct {
        db *sql.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *sql.DB) *UserRepository <span class="cov10" title="9">{
        return &amp;UserRepository{db: db}
}</span>

// Create creates a new user
func (r *UserRepository) Create(user *models.User) error <span class="cov5" title="3">{
        query := `
                INSERT INTO users (
                        name, email, phone, password_hash, experience_level, is_verified,
                        is_active, verification_token, verification_token_expires,
                        terms_accepted_at, last_activity_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(
                query,
                user.Name,
                user.Email,
                user.Phone,
                user.PasswordHash,
                user.ExperienceLevel,
                user.IsVerified,
                user.IsActive,
                user.VerificationToken,
                user.VerificationTokenExpires,
                user.TermsAcceptedAt,
                user.LastActivityAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov3" title="2">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user ID: %w", err)
        }</span>

        <span class="cov3" title="2">user.ID = int(id)
        return nil</span>
}

// FindByEmail finds a user by email
func (r *UserRepository) FindByEmail(email string) (*models.User, error) <span class="cov5" title="3">{
        query := `
                SELECT id, name, email, phone, password_hash, experience_level,
                       is_verified, is_active, is_deleted, verification_token,
                       verification_token_expires, password_reset_token,
                       password_reset_expires, profile_photo, anonymous_id,
                       terms_accepted_at, last_activity_at, deactivated_at,
                       deactivation_reason, reactivated_at, deleted_at,
                       created_at, updated_at
                FROM users
                WHERE email = ? AND is_deleted = 0
        `

        user := &amp;models.User{}
        err := r.db.QueryRow(query, email).Scan(
                &amp;user.ID,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.Phone,
                &amp;user.PasswordHash,
                &amp;user.ExperienceLevel,
                &amp;user.IsVerified,
                &amp;user.IsActive,
                &amp;user.IsDeleted,
                &amp;user.VerificationToken,
                &amp;user.VerificationTokenExpires,
                &amp;user.PasswordResetToken,
                &amp;user.PasswordResetExpires,
                &amp;user.ProfilePhoto,
                &amp;user.AnonymousID,
                &amp;user.TermsAcceptedAt,
                &amp;user.LastActivityAt,
                &amp;user.DeactivatedAt,
                &amp;user.DeactivationReason,
                &amp;user.ReactivatedAt,
                &amp;user.DeletedAt,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find user: %w", err)
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}

// FindByID finds a user by ID
func (r *UserRepository) FindByID(id int) (*models.User, error) <span class="cov8" title="7">{
        query := `
                SELECT id, name, email, phone, password_hash, experience_level,
                       is_verified, is_active, is_deleted, verification_token,
                       verification_token_expires, password_reset_token,
                       password_reset_expires, profile_photo, anonymous_id,
                       terms_accepted_at, last_activity_at, deactivated_at,
                       deactivation_reason, reactivated_at, deleted_at,
                       created_at, updated_at
                FROM users
                WHERE id = ?
        `

        user := &amp;models.User{}
        err := r.db.QueryRow(query, id).Scan(
                &amp;user.ID,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.Phone,
                &amp;user.PasswordHash,
                &amp;user.ExperienceLevel,
                &amp;user.IsVerified,
                &amp;user.IsActive,
                &amp;user.IsDeleted,
                &amp;user.VerificationToken,
                &amp;user.VerificationTokenExpires,
                &amp;user.PasswordResetToken,
                &amp;user.PasswordResetExpires,
                &amp;user.ProfilePhoto,
                &amp;user.AnonymousID,
                &amp;user.TermsAcceptedAt,
                &amp;user.LastActivityAt,
                &amp;user.DeactivatedAt,
                &amp;user.DeactivationReason,
                &amp;user.ReactivatedAt,
                &amp;user.DeletedAt,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov5" title="3">{
                return nil, nil
        }</span>
        <span class="cov6" title="4">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find user: %w", err)
        }</span>

        <span class="cov6" title="4">return user, nil</span>
}

// FindByVerificationToken finds a user by verification token
func (r *UserRepository) FindByVerificationToken(token string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, email, phone, password_hash, experience_level,
                       is_verified, is_active, is_deleted, verification_token,
                       verification_token_expires, password_reset_token,
                       password_reset_expires, profile_photo, anonymous_id,
                       terms_accepted_at, last_activity_at, deactivated_at,
                       deactivation_reason, reactivated_at, deleted_at,
                       created_at, updated_at
                FROM users
                WHERE verification_token = ? AND is_deleted = 0
        `

        user := &amp;models.User{}
        err := r.db.QueryRow(query, token).Scan(
                &amp;user.ID,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.Phone,
                &amp;user.PasswordHash,
                &amp;user.ExperienceLevel,
                &amp;user.IsVerified,
                &amp;user.IsActive,
                &amp;user.IsDeleted,
                &amp;user.VerificationToken,
                &amp;user.VerificationTokenExpires,
                &amp;user.PasswordResetToken,
                &amp;user.PasswordResetExpires,
                &amp;user.ProfilePhoto,
                &amp;user.AnonymousID,
                &amp;user.TermsAcceptedAt,
                &amp;user.LastActivityAt,
                &amp;user.DeactivatedAt,
                &amp;user.DeactivationReason,
                &amp;user.ReactivatedAt,
                &amp;user.DeletedAt,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// FindByPasswordResetToken finds a user by password reset token
func (r *UserRepository) FindByPasswordResetToken(token string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, email, phone, password_hash, experience_level,
                       is_verified, is_active, is_deleted, verification_token,
                       verification_token_expires, password_reset_token,
                       password_reset_expires, profile_photo, anonymous_id,
                       terms_accepted_at, last_activity_at, deactivated_at,
                       deactivation_reason, reactivated_at, deleted_at,
                       created_at, updated_at
                FROM users
                WHERE password_reset_token = ? AND is_deleted = 0
        `

        user := &amp;models.User{}
        err := r.db.QueryRow(query, token).Scan(
                &amp;user.ID,
                &amp;user.Name,
                &amp;user.Email,
                &amp;user.Phone,
                &amp;user.PasswordHash,
                &amp;user.ExperienceLevel,
                &amp;user.IsVerified,
                &amp;user.IsActive,
                &amp;user.IsDeleted,
                &amp;user.VerificationToken,
                &amp;user.VerificationTokenExpires,
                &amp;user.PasswordResetToken,
                &amp;user.PasswordResetExpires,
                &amp;user.ProfilePhoto,
                &amp;user.AnonymousID,
                &amp;user.TermsAcceptedAt,
                &amp;user.LastActivityAt,
                &amp;user.DeactivatedAt,
                &amp;user.DeactivationReason,
                &amp;user.ReactivatedAt,
                &amp;user.DeletedAt,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// Update updates a user
func (r *UserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users SET
                        name = ?,
                        email = ?,
                        phone = ?,
                        password_hash = ?,
                        experience_level = ?,
                        is_verified = ?,
                        is_active = ?,
                        is_deleted = ?,
                        verification_token = ?,
                        verification_token_expires = ?,
                        password_reset_token = ?,
                        password_reset_expires = ?,
                        profile_photo = ?,
                        anonymous_id = ?,
                        last_activity_at = ?,
                        deactivated_at = ?,
                        deactivation_reason = ?,
                        reactivated_at = ?,
                        deleted_at = ?,
                        updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(
                query,
                user.Name,
                user.Email,
                user.Phone,
                user.PasswordHash,
                user.ExperienceLevel,
                user.IsVerified,
                user.IsActive,
                user.IsDeleted,
                user.VerificationToken,
                user.VerificationTokenExpires,
                user.PasswordResetToken,
                user.PasswordResetExpires,
                user.ProfilePhoto,
                user.AnonymousID,
                user.LastActivityAt,
                user.DeactivatedAt,
                user.DeactivationReason,
                user.ReactivatedAt,
                user.DeletedAt,
                time.Now(),
                user.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateLastActivity updates the last activity timestamp
func (r *UserRepository) UpdateLastActivity(userID int) error <span class="cov3" title="2">{
        query := `UPDATE users SET last_activity_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, time.Now(), userID)
        return err
}</span>

// DeleteAccount performs GDPR-compliant account deletion (anonymization)
func (r *UserRepository) DeleteAccount(userID int) error <span class="cov3" title="2">{
        // Generate anonymous ID
        anonymousID := fmt.Sprintf("anonymous_user_%d", time.Now().Unix())

        query := `
                UPDATE users SET
                        name = 'Deleted User',
                        email = NULL,
                        phone = NULL,
                        password_hash = NULL,
                        profile_photo = NULL,
                        is_deleted = 1,
                        anonymous_id = ?,
                        deleted_at = ?,
                        updated_at = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, anonymousID, now, now, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete account: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Deactivate deactivates a user account
func (r *UserRepository) Deactivate(userID int, reason string) error <span class="cov5" title="3">{
        query := `
                UPDATE users SET
                        is_active = 0,
                        deactivated_at = ?,
                        deactivation_reason = ?,
                        updated_at = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, now, reason, now, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate user: %w", err)
        }</span>

        <span class="cov5" title="3">return nil</span>
}

// Activate activates a user account
func (r *UserRepository) Activate(userID int) error <span class="cov1" title="1">{
        query := `
                UPDATE users SET
                        is_active = 1,
                        reactivated_at = ?,
                        updated_at = ?
                WHERE id = ?
        `

        now := time.Now()
        _, err := r.db.Exec(query, now, now, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to activate user: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FindInactiveUsers finds users who haven't been active for the specified number of days
func (r *UserRepository) FindInactiveUsers(days int) ([]*models.User, error) <span class="cov1" title="1">{
        query := `
                SELECT id, name, email, phone, password_hash, experience_level,
                       is_verified, is_active, is_deleted, verification_token,
                       verification_token_expires, password_reset_token,
                       password_reset_expires, profile_photo, anonymous_id,
                       terms_accepted_at, last_activity_at, deactivated_at,
                       deactivation_reason, reactivated_at, deleted_at,
                       created_at, updated_at
                FROM users
                WHERE is_active = 1 
                  AND is_deleted = 0 
                  AND last_activity_at &lt; ?
        `

        cutoffDate := time.Now().AddDate(0, 0, -days)
        rows, err := r.db.Query(query, cutoffDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query inactive users: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        users := []*models.User{}
        for rows.Next() </span><span class="cov1" title="1">{
                user := &amp;models.User{}
                err := rows.Scan(
                        &amp;user.ID,
                        &amp;user.Name,
                        &amp;user.Email,
                        &amp;user.Phone,
                        &amp;user.PasswordHash,
                        &amp;user.ExperienceLevel,
                        &amp;user.IsVerified,
                        &amp;user.IsActive,
                        &amp;user.IsDeleted,
                        &amp;user.VerificationToken,
                        &amp;user.VerificationTokenExpires,
                        &amp;user.PasswordResetToken,
                        &amp;user.PasswordResetExpires,
                        &amp;user.ProfilePhoto,
                        &amp;user.AnonymousID,
                        &amp;user.TermsAcceptedAt,
                        &amp;user.LastActivityAt,
                        &amp;user.DeactivatedAt,
                        &amp;user.DeactivationReason,
                        &amp;user.ReactivatedAt,
                        &amp;user.DeletedAt,
                        &amp;user.CreatedAt,
                        &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov1" title="1">users = append(users, user)</span>
        }

        <span class="cov1" title="1">return users, nil</span>
}

// FindAll finds all users with optional filters
func (r *UserRepository) FindAll(activeOnly *bool) ([]*models.User, error) <span class="cov5" title="3">{
        query := `
                SELECT id, name, email, phone, password_hash, experience_level,
                       is_verified, is_active, is_deleted, verification_token,
                       verification_token_expires, password_reset_token,
                       password_reset_expires, profile_photo, anonymous_id,
                       terms_accepted_at, last_activity_at, deactivated_at,
                       deactivation_reason, reactivated_at, deleted_at,
                       created_at, updated_at
                FROM users
                WHERE is_deleted = 0
        `

        args := []interface{}{}

        if activeOnly != nil </span><span class="cov3" title="2">{
                if *activeOnly </span><span class="cov1" title="1">{
                        query += " AND is_active = 1"
                }</span> else<span class="cov1" title="1"> {
                        query += " AND is_active = 0"
                }</span>
        }

        <span class="cov5" title="3">query += " ORDER BY created_at DESC"

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query users: %w", err)
        }</span>
        <span class="cov5" title="3">defer rows.Close()

        users := []*models.User{}
        for rows.Next() </span><span class="cov6" title="4">{
                user := &amp;models.User{}
                err := rows.Scan(
                        &amp;user.ID,
                        &amp;user.Name,
                        &amp;user.Email,
                        &amp;user.Phone,
                        &amp;user.PasswordHash,
                        &amp;user.ExperienceLevel,
                        &amp;user.IsVerified,
                        &amp;user.IsActive,
                        &amp;user.IsDeleted,
                        &amp;user.VerificationToken,
                        &amp;user.VerificationTokenExpires,
                        &amp;user.PasswordResetToken,
                        &amp;user.PasswordResetExpires,
                        &amp;user.ProfilePhoto,
                        &amp;user.AnonymousID,
                        &amp;user.TermsAcceptedAt,
                        &amp;user.LastActivityAt,
                        &amp;user.DeactivatedAt,
                        &amp;user.DeactivationReason,
                        &amp;user.ReactivatedAt,
                        &amp;user.DeletedAt,
                        &amp;user.CreatedAt,
                        &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov6" title="4">users = append(users, user)</span>
        }

        <span class="cov5" title="3">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"
)

// AuthService provides authentication utilities
type AuthService struct {
        jwtSecret          string
        jwtExpirationHours int
}

// NewAuthService creates a new auth service
func NewAuthService(jwtSecret string, jwtExpirationHours int) *AuthService <span class="cov5" title="12">{
        return &amp;AuthService{
                jwtSecret:          jwtSecret,
                jwtExpirationHours: jwtExpirationHours,
        }
}</span>

// HashPassword hashes a password using bcrypt
func (s *AuthService) HashPassword(password string) (string, error) <span class="cov4" title="7">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 12)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov4" title="7">return string(bytes), nil</span>
}

// CheckPassword verifies a password against a hash
func (s *AuthService) CheckPassword(password, hash string) bool <span class="cov4" title="7">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

// GenerateToken generates a random token for verification or reset
func (s *AuthService) GenerateToken() (string, error) <span class="cov2" title="2">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate token: %w", err)
        }</span>
        <span class="cov2" title="2">return hex.EncodeToString(bytes), nil</span>
}

// GenerateJWT generates a JWT token for a user
func (s *AuthService) GenerateJWT(userID int, email string, isAdmin bool) (string, error) <span class="cov4" title="6">{
        claims := jwt.MapClaims{
                "user_id":  userID,
                "email":    email,
                "is_admin": isAdmin,
                "exp":      time.Now().Add(time.Hour * time.Duration(s.jwtExpirationHours)).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(s.jwtSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov4" title="6">return tokenString, nil</span>
}

// ValidateJWT validates and parses a JWT token
func (s *AuthService) ValidateJWT(tokenString string) (*jwt.MapClaims, error) <span class="cov5" title="10">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov4" title="6">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov4" title="6">return []byte(s.jwtSecret), nil</span>
        })

        <span class="cov5" title="10">if err != nil </span><span class="cov4" title="7">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov2" title="3">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov2" title="3">{
                return &amp;claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

// ValidatePassword checks if a password meets requirements
func (s *AuthService) ValidatePassword(password string) error <span class="cov5" title="16">{
        if len(password) &lt; 8 </span><span class="cov2" title="3">{
                return fmt.Errorf("password must be at least 8 characters long")
        }</span>

        <span class="cov5" title="13">hasUpper := false
        hasLower := false
        hasNumber := false

        for _, char := range password </span><span class="cov10" title="156">{
                switch </span>{
                case 'A' &lt;= char &amp;&amp; char &lt;= 'Z':<span class="cov6" title="26">
                        hasUpper = true</span>
                case 'a' &lt;= char &amp;&amp; char &lt;= 'z':<span class="cov8" title="58">
                        hasLower = true</span>
                case '0' &lt;= char &amp;&amp; char &lt;= '9':<span class="cov8" title="59">
                        hasNumber = true</span>
                }
        }

        <span class="cov5" title="13">if !hasUpper </span><span class="cov3" title="5">{
                return fmt.Errorf("password must contain at least one uppercase letter")
        }</span>
        <span class="cov4" title="8">if !hasLower </span><span class="cov2" title="2">{
                return fmt.Errorf("password must contain at least one lowercase letter")
        }</span>
        <span class="cov4" title="6">if !hasNumber </span><span class="cov1" title="1">{
                return fmt.Errorf("password must contain at least one number")
        }</span>

        <span class="cov3" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "bytes"
        "fmt"
        "html/template"
)

// SendAccountDeactivated sends an email when account is deactivated
func (s *EmailService) SendAccountDeactivated(to, name, reason string) error <span class="cov0" title="0">{
        subject := "Ihr Konto wurde deaktiviert - Gassigeher"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #ffc107; color: #26272b; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .warning-box { background-color: #fff3cd; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #ffc107; }
        .info-box { background-color: white; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #17a2b8; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Ihr Konto wurde deaktiviert&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihr Konto wurde deaktiviert und Sie knnen sich derzeit nicht anmelden.&lt;/p&gt;

            &lt;div class="warning-box"&gt;
                &lt;strong&gt;Grund der Deaktivierung:&lt;/strong&gt;&lt;br&gt;
                {{.Reason}}
            &lt;/div&gt;

            &lt;div class="info-box"&gt;
                &lt;h4 style="margin-top: 0;"&gt;Wie kann ich mein Konto reaktivieren?&lt;/h4&gt;
                &lt;p&gt;Wenn Sie Ihr Konto reaktivieren mchten, knnen Sie eine Reaktivierungsanfrage stellen. Ein Administrator wird Ihre Anfrage prfen.&lt;/p&gt;
            &lt;/div&gt;

            &lt;p&gt;Bei Fragen wenden Sie sich bitte an unseren Support.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("deactivated").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name":   name,
                "Reason": reason,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendAccountReactivated sends an email when account is reactivated
func (s *EmailService) SendAccountReactivated(to, name string, message *string) error <span class="cov0" title="0">{
        subject := "Ihr Konto wurde wieder aktiviert - Gassigeher"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #28a745; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .success-box { background-color: #d4edda; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #28a745; }
        .message-box { background-color: white; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #17a2b8; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Willkommen zurck!&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihr Konto wurde reaktiviert und Sie knnen sich wieder anmelden!&lt;/p&gt;

            &lt;div class="success-box"&gt;
                &lt;p style="margin: 0;"&gt;Sie knnen jetzt wieder:&lt;/p&gt;
                &lt;ul style="margin: 10px 0;"&gt;
                    &lt;li&gt;Hunde buchen&lt;/li&gt;
                    &lt;li&gt;Ihre Buchungen verwalten&lt;/li&gt;
                    &lt;li&gt;Ihr Profil bearbeiten&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;

            {{if .Message}}
            &lt;div class="message-box"&gt;
                &lt;strong&gt;Nachricht vom Administrator:&lt;/strong&gt;&lt;br&gt;
                {{.Message}}
            &lt;/div&gt;
            {{end}}

            &lt;p style="text-align: center; margin-top: 30px;"&gt;
                &lt;a href="http://localhost:8080/login.html" style="display: inline-block; padding: 12px 30px; background-color: #82b965; color: white; text-decoration: none; border-radius: 6px;"&gt;Jetzt anmelden&lt;/a&gt;
            &lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("reactivated").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]interface{}{
                "Name": name,
                "Message": func() string </span><span class="cov0" title="0">{
                        if message != nil </span><span class="cov0" title="0">{
                                return *message
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }
        <span class="cov0" title="0">if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendReactivationDenied sends an email when reactivation request is denied
func (s *EmailService) SendReactivationDenied(to, name string, message *string) error <span class="cov0" title="0">{
        subject := "Ihre Reaktivierungsanfrage - Gassigeher"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #dc3545; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .info-box { background-color: #fff3cd; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #ffc107; }
        .message-box { background-color: white; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #17a2b8; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Reaktivierungsanfrage&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Vielen Dank fr Ihre Reaktivierungsanfrage.&lt;/p&gt;

            &lt;div class="info-box"&gt;
                &lt;p style="margin: 0;"&gt;
                    Leider knnen wir Ihre Anfrage derzeit nicht genehmigen. Ihr Konto bleibt deaktiviert.
                &lt;/p&gt;
            &lt;/div&gt;

            {{if .Message}}
            &lt;div class="message-box"&gt;
                &lt;strong&gt;Nachricht vom Administrator:&lt;/strong&gt;&lt;br&gt;
                {{.Message}}
            &lt;/div&gt;
            {{end}}

            &lt;p&gt;Bei Fragen wenden Sie sich bitte an unseren Support.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("denied_reactivation").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]interface{}{
                "Name": name,
                "Message": func() string </span><span class="cov0" title="0">{
                        if message != nil </span><span class="cov0" title="0">{
                                return *message
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }
        <span class="cov0" title="0">if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendAccountDeletionConfirmation sends a confirmation email after account deletion
func (s *EmailService) SendAccountDeletionConfirmation(to, name string) error <span class="cov0" title="0">{
        subject := "Ihr Konto wurde gelscht - Gassigeher"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #dc3545; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .info-box { background-color: #fff3cd; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #ffc107; }
        .detail-box { background-color: white; padding: 20px; margin: 20px 0; border-radius: 6px; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Ihr Konto wurde gelscht&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihre Lschungsanfrage wurde durchgefhrt. Ihr Konto wurde gem DSGVO-Richtlinien gelscht.&lt;/p&gt;

            &lt;div class="detail-box"&gt;
                &lt;h4 style="margin-top: 0;"&gt;Was wurde gelscht:&lt;/h4&gt;
                &lt;ul style="margin: 10px 0;"&gt;
                    &lt;li&gt;Ihre persnlichen Daten (Name, E-Mail, Telefon)&lt;/li&gt;
                    &lt;li&gt;Ihr Passwort&lt;/li&gt;
                    &lt;li&gt;Ihr Profilfoto&lt;/li&gt;
                &lt;/ul&gt;

                &lt;h4&gt;Was wurde anonymisiert:&lt;/h4&gt;
                &lt;ul style="margin: 10px 0;"&gt;
                    &lt;li&gt;Ihre Spaziergangshistorie (fr Hundepflegeaufzeichnungen)&lt;/li&gt;
                    &lt;li&gt;Ihre Notizen zu Spaziergngen&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;

            &lt;div class="info-box"&gt;
                &lt;strong&gt;Rechtliche Hinweise:&lt;/strong&gt;
                &lt;p style="margin: 10px 0;"&gt;
                    Diese E-Mail dient als rechtlicher Nachweis Ihrer Kontolschung. Die Spaziergangshistorie wird aus legitimen Interessen der Tierpflege aufbewahrt, aber vollstndig anonymisiert.
                &lt;/p&gt;
            &lt;/div&gt;

            &lt;p&gt;Vielen Dank, dass Sie Gassigeher genutzt haben.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("deletion").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name": name,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "html/template"
        "log"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"
        "google.golang.org/api/gmail/v1"
        "google.golang.org/api/option"
)

// EmailService handles sending emails via Gmail API
type EmailService struct {
        service   *gmail.Service
        fromEmail string
}

// NewEmailService creates a new email service
func NewEmailService(clientID, clientSecret, refreshToken, fromEmail string) (*EmailService, error) <span class="cov0" title="0">{
        config := &amp;oauth2.Config{
                ClientID:     clientID,
                ClientSecret: clientSecret,
                Endpoint:     google.Endpoint,
                Scopes:       []string{gmail.GmailSendScope},
        }

        token := &amp;oauth2.Token{
                RefreshToken: refreshToken,
                TokenType:    "Bearer",
        }

        client := config.Client(oauth2.NoContext, token)

        service, err := gmail.NewService(oauth2.NoContext, option.WithHTTPClient(client))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Gmail service: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;EmailService{
                service:   service,
                fromEmail: fromEmail,
        }, nil</span>
}

// SendEmail sends an email
func (s *EmailService) SendEmail(to, subject, body string) error <span class="cov0" title="0">{
        var message gmail.Message

        emailContent := fmt.Sprintf("From: %s\r\n"+
                "To: %s\r\n"+
                "Subject: %s\r\n"+
                "Content-Type: text/html; charset=UTF-8\r\n\r\n"+
                "%s", s.fromEmail, to, subject, body)

        message.Raw = base64.URLEncoding.EncodeToString([]byte(emailContent))

        _, err := s.service.Users.Messages.Send("me", &amp;message).Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Email sent to %s: %s", to, subject)
        return nil</span>
}

// SendVerificationEmail sends an email verification link
func (s *EmailService) SendVerificationEmail(to, name, token string) error <span class="cov0" title="0">{
        subject := "Willkommen bei Gassigeher - E-Mail-Adresse besttigen"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Titillium, Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #82b965; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .button { display: inline-block; padding: 12px 30px; background-color: #82b965; color: white; text-decoration: none; border-radius: 6px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt; Willkommen bei Gassigeher&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;vielen Dank fr Ihre Registrierung bei Gassigeher! Bitte besttigen Sie Ihre E-Mail-Adresse, um Ihr Konto zu aktivieren.&lt;/p&gt;
            &lt;p style="text-align: center;"&gt;
                &lt;a href="http://localhost:8080/verify?token={{.Token}}" class="button"&gt;E-Mail-Adresse besttigen&lt;/a&gt;
            &lt;/p&gt;
            &lt;p&gt;Oder kopieren Sie diesen Link in Ihren Browser:&lt;/p&gt;
            &lt;p style="word-break: break-all; font-size: 12px; color: #666;"&gt;
                http://localhost:8080/verify?token={{.Token}}
            &lt;/p&gt;
            &lt;p&gt;Dieser Link ist 24 Stunden gltig.&lt;/p&gt;
            &lt;p&gt;Wenn Sie sich nicht bei Gassigeher registriert haben, knnen Sie diese E-Mail ignorieren.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("verification").Parse(tmpl))
        var body bytes.Buffer
        if err := t.Execute(&amp;body, map[string]string{"Name": name, "Token": token}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendWelcomeEmail sends a welcome email after verification
func (s *EmailService) SendWelcomeEmail(to, name string) error <span class="cov0" title="0">{
        subject := "Los geht's! Ihr Konto ist aktiviert"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Titillium, Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #82b965; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .feature { margin: 15px 0; padding: 15px; background-color: white; border-left: 4px solid #82b965; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt; Willkommen bei Gassigeher!&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihr Konto ist jetzt aktiviert! Sie knnen sofort mit dem Buchen von Hunden beginnen.&lt;/p&gt;

            &lt;h3&gt;So funktioniert's:&lt;/h3&gt;

            &lt;div class="feature"&gt;
                &lt;strong&gt; Hunde durchsuchen&lt;/strong&gt;&lt;br&gt;
                Sehen Sie sich alle verfgbaren Hunde an und filtern Sie nach Gre, Rasse und Erfahrungslevel.
            &lt;/div&gt;

            &lt;div class="feature"&gt;
                &lt;strong&gt; Termine buchen&lt;/strong&gt;&lt;br&gt;
                Whlen Sie einen Hund und einen Zeitpunkt fr Ihren Spaziergang. Sie knnen die vorgeschlagenen Zeiten anpassen.
            &lt;/div&gt;

            &lt;div class="feature"&gt;
                &lt;strong&gt; Erfahrungslevel&lt;/strong&gt;&lt;br&gt;
                Sie starten als "Grn" (Anfnger). Sie knnen hhere Levels beantragen, um Zugang zu anspruchsvolleren Hunden zu erhalten:
                &lt;ul&gt;
                    &lt;li&gt;&lt;strong&gt;Grn:&lt;/strong&gt; Alle Anfnger (Standard)&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Blau:&lt;/strong&gt; Erfahrene Gassigeher&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Orange:&lt;/strong&gt; Nur erfahrene Gassigeher&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;

            &lt;p&gt;Bei Fragen oder Problemen wenden Sie sich bitte an unseren Support.&lt;/p&gt;

            &lt;p style="text-align: center; margin-top: 30px;"&gt;
                &lt;a href="http://localhost:8080" style="display: inline-block; padding: 12px 30px; background-color: #82b965; color: white; text-decoration: none; border-radius: 6px;"&gt;Zur Anwendung&lt;/a&gt;
            &lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("welcome").Parse(tmpl))
        var body bytes.Buffer
        if err := t.Execute(&amp;body, map[string]string{"Name": name}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendPasswordResetEmail sends a password reset link
func (s *EmailService) SendPasswordResetEmail(to, name, token string) error <span class="cov0" title="0">{
        subject := "Passwort zurcksetzen - Gassigeher"

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Titillium, Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #82b965; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .button { display: inline-block; padding: 12px 30px; background-color: #82b965; color: white; text-decoration: none; border-radius: 6px; margin: 20px 0; }
        .warning { background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt; Passwort zurcksetzen&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Sie haben eine Anfrage zum Zurcksetzen Ihres Passworts gestellt. Klicken Sie auf den Button unten, um ein neues Passwort festzulegen.&lt;/p&gt;
            &lt;p style="text-align: center;"&gt;
                &lt;a href="http://localhost:8080/reset-password?token={{.Token}}" class="button"&gt;Neues Passwort festlegen&lt;/a&gt;
            &lt;/p&gt;
            &lt;p&gt;Oder kopieren Sie diesen Link in Ihren Browser:&lt;/p&gt;
            &lt;p style="word-break: break-all; font-size: 12px; color: #666;"&gt;
                http://localhost:8080/reset-password?token={{.Token}}
            &lt;/p&gt;
            &lt;div class="warning"&gt;
                &lt;strong&gt; Wichtig:&lt;/strong&gt; Dieser Link ist nur 1 Stunde gltig.
            &lt;/div&gt;
            &lt;p&gt;Wenn Sie diese Anfrage nicht gestellt haben, knnen Sie diese E-Mail ignorieren. Ihr Passwort bleibt unverndert.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("reset").Parse(tmpl))
        var body bytes.Buffer
        if err := t.Execute(&amp;body, map[string]string{"Name": name, "Token": token}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendBookingConfirmation sends a booking confirmation email
func (s *EmailService) SendBookingConfirmation(to, name, dogName, date, walkType, scheduledTime string) error <span class="cov0" title="0">{
        subject := fmt.Sprintf("Buchungsbesttigung - %s", dogName)

        walkTypeLabel := "Morgen"
        if walkType == "evening" </span><span class="cov0" title="0">{
                walkTypeLabel = "Abend"
        }</span>

        <span class="cov0" title="0">tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #82b965; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .booking-details { background-color: white; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #82b965; }
        .detail-row { margin: 10px 0; }
        .label { font-weight: 600; color: #666; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt; Buchung besttigt!&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihre Buchung wurde erfolgreich besttigt.&lt;/p&gt;

            &lt;div class="booking-details"&gt;
                &lt;h3 style="margin-top: 0;"&gt;Buchungsdetails&lt;/h3&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Hund:&lt;/span&gt; {{.DogName}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Datum:&lt;/span&gt; {{.Date}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Spaziergang:&lt;/span&gt; {{.WalkType}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Uhrzeit:&lt;/span&gt; {{.ScheduledTime}} Uhr
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;p&gt;Sie erhalten eine Erinnerung 1 Stunde vor Ihrem Spaziergang.&lt;/p&gt;
            &lt;p&gt;Falls Sie den Termin stornieren mchten, tun Sie dies bitte mindestens 12 Stunden im Voraus ber Ihr Dashboard.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("booking").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name":          name,
                "DogName":       dogName,
                "Date":          date,
                "WalkType":      walkTypeLabel,
                "ScheduledTime": scheduledTime,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendBookingCancellation sends a booking cancellation confirmation (user-initiated)
func (s *EmailService) SendBookingCancellation(to, name, dogName, date, walkType string) error <span class="cov0" title="0">{
        subject := fmt.Sprintf("Buchung storniert - %s", dogName)

        walkTypeLabel := "Morgen"
        if walkType == "evening" </span><span class="cov0" title="0">{
                walkTypeLabel = "Abend"
        }</span>

        <span class="cov0" title="0">tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #dc3545; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .booking-details { background-color: white; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #dc3545; }
        .detail-row { margin: 10px 0; }
        .label { font-weight: 600; color: #666; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Buchung storniert&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihre Buchung wurde erfolgreich storniert.&lt;/p&gt;

            &lt;div class="booking-details"&gt;
                &lt;h3 style="margin-top: 0;"&gt;Stornierte Buchung&lt;/h3&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Hund:&lt;/span&gt; {{.DogName}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Datum:&lt;/span&gt; {{.Date}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Spaziergang:&lt;/span&gt; {{.WalkType}}
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;p&gt;Sie knnen jederzeit eine neue Buchung vornehmen.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("cancellation").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name":     name,
                "DogName":  dogName,
                "Date":     date,
                "WalkType": walkTypeLabel,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendAdminCancellation sends an admin cancellation notification
func (s *EmailService) SendAdminCancellation(to, name, dogName, date, walkType, reason string) error <span class="cov0" title="0">{
        subject := fmt.Sprintf("Deine Buchung wurde storniert - %s", dogName)

        walkTypeLabel := "Morgen"
        if walkType == "evening" </span><span class="cov0" title="0">{
                walkTypeLabel = "Abend"
        }</span>

        <span class="cov0" title="0">tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #dc3545; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .booking-details { background-color: white; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #dc3545; }
        .reason-box { background-color: #fff3cd; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #ffc107; }
        .detail-row { margin: 10px 0; }
        .label { font-weight: 600; color: #666; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Buchung storniert&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Leider mussten wir Ihre folgende Buchung stornieren:&lt;/p&gt;

            &lt;div class="booking-details"&gt;
                &lt;h3 style="margin-top: 0;"&gt;Stornierte Buchung&lt;/h3&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Hund:&lt;/span&gt; {{.DogName}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Datum:&lt;/span&gt; {{.Date}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Spaziergang:&lt;/span&gt; {{.WalkType}}
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="reason-box"&gt;
                &lt;strong&gt;Grund der Stornierung:&lt;/strong&gt;&lt;br&gt;
                {{.Reason}}
            &lt;/div&gt;

            &lt;p&gt;Wir entschuldigen uns fr die Unannehmlichkeiten. Sie knnen gerne einen anderen Termin buchen.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("admin_cancel").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name":     name,
                "DogName":  dogName,
                "Date":     date,
                "WalkType": walkTypeLabel,
                "Reason":   reason,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendBookingReminder sends a reminder 1 hour before the booking
func (s *EmailService) SendBookingReminder(to, name, dogName, date, walkType, scheduledTime string) error <span class="cov0" title="0">{
        subject := fmt.Sprintf("Erinnerung: Gassirunde mit %s in 1 Stunde", dogName)

        walkTypeLabel := "Morgen"
        if walkType == "evening" </span><span class="cov0" title="0">{
                walkTypeLabel = "Abend"
        }</span>

        <span class="cov0" title="0">tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #17a2b8; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .booking-details { background-color: white; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #17a2b8; }
        .detail-row { margin: 10px 0; }
        .label { font-weight: 600; color: #666; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt; Erinnerung&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Dies ist eine Erinnerung an Ihren bevorstehenden Spaziergang:&lt;/p&gt;

            &lt;div class="booking-details"&gt;
                &lt;h3 style="margin-top: 0;"&gt;Ihr Spaziergang&lt;/h3&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Hund:&lt;/span&gt; {{.DogName}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Datum:&lt;/span&gt; {{.Date}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Spaziergang:&lt;/span&gt; {{.WalkType}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Uhrzeit:&lt;/span&gt; {{.ScheduledTime}} Uhr
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;p&gt;Viel Spa beim Spaziergang!&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("reminder").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name":          name,
                "DogName":       dogName,
                "Date":          date,
                "WalkType":      walkTypeLabel,
                "ScheduledTime": scheduledTime,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendBookingMoved sends an email when admin moves a booking
func (s *EmailService) SendBookingMoved(to, name, dogName, oldDate, oldWalkType, oldTime, newDate, newWalkType, newTime, reason string) error <span class="cov0" title="0">{
        subject := fmt.Sprintf("Deine Buchung wurde verschoben - %s", dogName)

        oldWalkLabel := "Morgen"
        if oldWalkType == "evening" </span><span class="cov0" title="0">{
                oldWalkLabel = "Abend"
        }</span>

        <span class="cov0" title="0">newWalkLabel := "Morgen"
        if newWalkType == "evening" </span><span class="cov0" title="0">{
                newWalkLabel = "Abend"
        }</span>

        <span class="cov0" title="0">tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #17a2b8; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .booking-details { background-color: white; padding: 20px; margin: 20px 0; border-radius: 6px; }
        .old-details { border-left: 4px solid #dc3545; }
        .new-details { border-left: 4px solid #28a745; margin-top: 20px; }
        .reason-box { background-color: #fff3cd; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #ffc107; }
        .detail-row { margin: 10px 0; }
        .label { font-weight: 600; color: #666; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Buchung verschoben&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihre Buchung wurde auf einen neuen Termin verschoben:&lt;/p&gt;

            &lt;div class="booking-details old-details"&gt;
                &lt;h3 style="margin-top: 0; color: #dc3545;"&gt;Alter Termin&lt;/h3&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Hund:&lt;/span&gt; {{.DogName}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Datum:&lt;/span&gt; {{.OldDate}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Spaziergang:&lt;/span&gt; {{.OldWalkType}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Uhrzeit:&lt;/span&gt; {{.OldTime}} Uhr
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="booking-details new-details"&gt;
                &lt;h3 style="margin-top: 0; color: #28a745;"&gt;Neuer Termin&lt;/h3&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Hund:&lt;/span&gt; {{.DogName}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Datum:&lt;/span&gt; {{.NewDate}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Spaziergang:&lt;/span&gt; {{.NewWalkType}}
                &lt;/div&gt;
                &lt;div class="detail-row"&gt;
                    &lt;span class="label"&gt;Uhrzeit:&lt;/span&gt; {{.NewTime}} Uhr
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class="reason-box"&gt;
                &lt;strong&gt;Grund der Verschiebung:&lt;/strong&gt;&lt;br&gt;
                {{.Reason}}
            &lt;/div&gt;

            &lt;p&gt;Wir entschuldigen uns fr die Unannehmlichkeiten. Bei Fragen oder Problemen wenden Sie sich bitte an uns.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("moved").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]string{
                "Name":        name,
                "DogName":     dogName,
                "OldDate":     oldDate,
                "OldWalkType": oldWalkLabel,
                "OldTime":     oldTime,
                "NewDate":     newDate,
                "NewWalkType": newWalkLabel,
                "NewTime":     newTime,
                "Reason":      reason,
        }
        if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendExperienceLevelApproved sends an email when experience level request is approved
func (s *EmailService) SendExperienceLevelApproved(to, name, level string, message *string) error <span class="cov0" title="0">{
        levelLabel := "Blau"
        if level == "orange" </span><span class="cov0" title="0">{
                levelLabel = "Orange"
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("Ihr Antrag auf %s Level wurde genehmigt", levelLabel)

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #28a745; color: white; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .success-box { background-color: #d4edda; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #28a745; }
        .message-box { background-color: white; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #17a2b8; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt; Glckwunsch!&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Ihr Antrag auf &lt;strong&gt;{{.Level}} Level&lt;/strong&gt; wurde genehmigt!&lt;/p&gt;

            &lt;div class="success-box"&gt;
                &lt;h3 style="margin-top: 0;"&gt;Sie haben jetzt Zugang zu:&lt;/h3&gt;
                &lt;p style="margin: 5px 0;"&gt;
                    {{if eq .Level "Blau"}}
                     Grne Hunde (Anfnger)&lt;br&gt;
                     Blaue Hunde (Erfahrene)
                    {{else}}
                     Grne Hunde (Anfnger)&lt;br&gt;
                     Blaue Hunde (Erfahrene)&lt;br&gt;
                     Orange Hunde (Nur Erfahrene)
                    {{end}}
                &lt;/p&gt;
            &lt;/div&gt;

            {{if .Message}}
            &lt;div class="message-box"&gt;
                &lt;strong&gt;Nachricht vom Administrator:&lt;/strong&gt;&lt;br&gt;
                {{.Message}}
            &lt;/div&gt;
            {{end}}

            &lt;p&gt;Sie knnen jetzt sofort Hunde Ihres neuen Levels buchen!&lt;/p&gt;

            &lt;p style="text-align: center; margin-top: 30px;"&gt;
                &lt;a href="http://localhost:8080/dogs.html" style="display: inline-block; padding: 12px 30px; background-color: #82b965; color: white; text-decoration: none; border-radius: 6px;"&gt;Hunde anzeigen&lt;/a&gt;
            &lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("approved").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]interface{}{
                "Name":  name,
                "Level": levelLabel,
                "Message": func() string </span><span class="cov0" title="0">{
                        if message != nil </span><span class="cov0" title="0">{
                                return *message
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }
        <span class="cov0" title="0">if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}

// SendExperienceLevelDenied sends an email when experience level request is denied
func (s *EmailService) SendExperienceLevelDenied(to, name, level string, message *string) error <span class="cov0" title="0">{
        levelLabel := "Blau"
        if level == "orange" </span><span class="cov0" title="0">{
                levelLabel = "Orange"
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("Ihr Antrag auf %s Level", levelLabel)

        tmpl := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #26272b; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background-color: #ffc107; color: #26272b; padding: 20px; text-align: center; border-radius: 6px 6px 0 0; }
        .content { background-color: #f9f9f9; padding: 30px; border-radius: 0 0 6px 6px; }
        .info-box { background-color: #fff3cd; padding: 20px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #ffc107; }
        .message-box { background-color: white; padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #17a2b8; }
        .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Ihr Antrag auf {{.Level}} Level&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class="content"&gt;
            &lt;p&gt;Hallo {{.Name}},&lt;/p&gt;
            &lt;p&gt;Vielen Dank fr Ihren Antrag auf &lt;strong&gt;{{.Level}} Level&lt;/strong&gt;.&lt;/p&gt;

            &lt;div class="info-box"&gt;
                &lt;p style="margin: 0;"&gt;
                    Leider knnen wir Ihren Antrag derzeit nicht genehmigen. Sammeln Sie weiterhin Erfahrung und versuchen Sie es spter erneut!
                &lt;/p&gt;
            &lt;/div&gt;

            {{if .Message}}
            &lt;div class="message-box"&gt;
                &lt;strong&gt;Nachricht vom Administrator:&lt;/strong&gt;&lt;br&gt;
                {{.Message}}
            &lt;/div&gt;
            {{end}}

            &lt;p&gt;Sie knnen weiterhin Hunde Ihres aktuellen Levels buchen und jederzeit einen neuen Antrag stellen.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;p&gt; 2025 Gassigeher. Alle Rechte vorbehalten.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        t := template.Must(template.New("denied").Parse(tmpl))
        var body bytes.Buffer
        data := map[string]interface{}{
                "Name":  name,
                "Level": levelLabel,
                "Message": func() string </span><span class="cov0" title="0">{
                        if message != nil </span><span class="cov0" title="0">{
                                return *message
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }
        <span class="cov0" title="0">if err := t.Execute(&amp;body, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return s.SendEmail(to, subject, body.String())</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package testutil

import (
        "database/sql"
        "testing"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "github.com/tranm/gassigeher/internal/database"
)

// DONE: SetupTestDB creates an in-memory SQLite database for testing
func SetupTestDB(t *testing.T) *sql.DB <span class="cov0" title="0">{
        db, err := sql.Open("sqlite3", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to open test database: %v", err)
        }</span>

        // Run migrations
        <span class="cov0" title="0">err = database.RunMigrations(db)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to run migrations: %v", err)
        }</span>

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                db.Close()
        }</span>)

        <span class="cov0" title="0">return db</span>
}

// DONE: SeedTestUser creates a test user and returns the ID
func SeedTestUser(t *testing.T, db *sql.DB, email, name, level string) int <span class="cov0" title="0">{
        now := time.Now()
        result, err := db.Exec(`
                INSERT INTO users (email, name, phone, password_hash, experience_level, is_verified, is_active, terms_accepted_at, last_activity_at, created_at)
                VALUES (?, ?, ?, ?, ?, 1, 1, ?, ?, ?)
        `, email, name, "+49 123 456789", "test_hash", level, now, now, now)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to seed test user: %v", err)
        }</span>

        <span class="cov0" title="0">id, _ := result.LastInsertId()
        return int(id)</span>
}

// DONE: SeedTestDog creates a test dog and returns the ID
func SeedTestDog(t *testing.T, db *sql.DB, name, breed, category string) int <span class="cov0" title="0">{
        now := time.Now()
        result, err := db.Exec(`
                INSERT INTO dogs (name, breed, size, age, category, is_available, created_at)
                VALUES (?, ?, ?, ?, ?, 1, ?)
        `, name, breed, "medium", 5, category, now)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to seed test dog: %v", err)
        }</span>

        <span class="cov0" title="0">id, _ := result.LastInsertId()
        return int(id)</span>
}

// DONE: SeedTestBooking creates a test booking and returns the ID
func SeedTestBooking(t *testing.T, db *sql.DB, userID, dogID int, date, walkType, scheduledTime, status string) int <span class="cov0" title="0">{
        now := time.Now()
        result, err := db.Exec(`
                INSERT INTO bookings (user_id, dog_id, date, walk_type, scheduled_time, status, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `, userID, dogID, date, walkType, scheduledTime, status, now)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to seed test booking: %v", err)
        }</span>

        <span class="cov0" title="0">id, _ := result.LastInsertId()
        return int(id)</span>
}

// DONE: SeedTestBlockedDate creates a test blocked date and returns the ID
func SeedTestBlockedDate(t *testing.T, db *sql.DB, date, reason string, createdBy int) int <span class="cov0" title="0">{
        now := time.Now()
        result, err := db.Exec(`
                INSERT INTO blocked_dates (date, reason, created_by, created_at)
                VALUES (?, ?, ?, ?)
        `, date, reason, createdBy, now)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to seed test blocked date: %v", err)
        }</span>

        <span class="cov0" title="0">id, _ := result.LastInsertId()
        return int(id)</span>
}

// DONE: SeedTestExperienceRequest creates a test experience request and returns the ID
func SeedTestExperienceRequest(t *testing.T, db *sql.DB, userID int, requestedLevel, status string) int <span class="cov0" title="0">{
        now := time.Now()
        result, err := db.Exec(`
                INSERT INTO experience_requests (user_id, requested_level, status, created_at)
                VALUES (?, ?, ?, ?)
        `, userID, requestedLevel, status, now)

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to seed test experience request: %v", err)
        }</span>

        <span class="cov0" title="0">id, _ := result.LastInsertId()
        return int(id)</span>
}

// DONE: CountRows returns the count of rows in a table
func CountRows(t *testing.T, db *sql.DB, table string) int <span class="cov0" title="0">{
        var count int
        err := db.QueryRow("SELECT COUNT(*) FROM " + table).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to count rows in %s: %v", table, err)
        }</span>
        <span class="cov0" title="0">return count</span>
}

// DONE: ClearTable deletes all rows from a table
func ClearTable(t *testing.T, db *sql.DB, table string) <span class="cov0" title="0">{
        _, err := db.Exec("DELETE FROM " + table)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to clear table %s: %v", table, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Quick utility to generate bcrypt hash for test password
// Usage: go run scripts/genhash.go test123

package main

import (
        "fmt"
        "os"

        "golang.org/x/crypto/bcrypt"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: go run genhash.go &lt;password&gt;")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">password := os.Args[1]
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error generating hash: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Password: %s\n", password)
        fmt.Printf("Bcrypt Hash: %s\n", string(hash))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
